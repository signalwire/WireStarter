# Better history settings
export HISTSIZE=10000
export HISTFILESIZE=20000
export HISTCONTROL=ignoredups:erasedups
shopt -s histappend

# Prompt helper functions (output raw text, no escapes)
__git_info() {
    local branch=$(git symbolic-ref --short HEAD 2>/dev/null)
    if [ -n "$branch" ]; then
        local status=""
        local rev=$(git rev-parse --short HEAD 2>/dev/null)
        # Check for uncommitted changes
        if ! git diff --quiet 2>/dev/null || ! git diff --cached --quiet 2>/dev/null; then
            status="*"
        fi
        # Check for untracked files
        if [ -n "$(git ls-files --others --exclude-standard 2>/dev/null)" ]; then
            status="${status}+"
        fi
        echo "${branch}:${rev}${status}"
    fi
}

__venv_info() {
    if [ -n "$VIRTUAL_ENV" ]; then
        basename "$VIRTUAL_ENV"
    fi
}

__short_pwd() {
    echo "$PWD"
}

__exit_status() {
    local code=$?
    if [ $code -ne 0 ]; then
        echo "$code"
    fi
}

# Build prompt using PROMPT_COMMAND to capture exit code, then set PS1
__build_prompt() {
    local EXIT=$?

    # Colors (raw escape codes for PROMPT_COMMAND context)
    local RST='\[\e[0m\]'
    local BOLD='\[\e[1m\]'
    local DIM='\[\e[2m\]'
    local RED='\[\e[31m\]'
    local GRN='\[\e[32m\]'
    local YLW='\[\e[33m\]'
    local BLU='\[\e[34m\]'
    local MAG='\[\e[35m\]'
    local CYN='\[\e[36m\]'

    # Get dynamic values
    local git_info=$(__git_info)
    local venv_info=$(__venv_info)
    local short_pwd=$(__short_pwd)

    # Start building PS1
    local PS1_LINE1=""
    local PS1_LINE2=""

    # Line 1: [exit] time path (git) [venv]
    PS1_LINE1="\n"

    # Exit code if non-zero
    if [ $EXIT -ne 0 ]; then
        PS1_LINE1+="${RED}[$EXIT]${RST} "
    fi

    # Time
    PS1_LINE1+="${DIM}\t${RST} "

    # Path
    PS1_LINE1+="${BOLD}${CYN}${short_pwd}${RST}"

    # Git info
    if [ -n "$git_info" ]; then
        PS1_LINE1+=" ${YLW}(${git_info})${RST}"
    fi

    # Venv info
    if [ -n "$venv_info" ]; then
        PS1_LINE1+=" ${MAG}[py:${venv_info}]${RST}"
    fi

    # Line 2: prompt character
    PS1_LINE2="\n${GRN}\$${RST} "

    PS1="${PS1_LINE1}${PS1_LINE2}"
}

PROMPT_COMMAND=__build_prompt

if [ -f "/workdir/.env" ]; then
    set -a
    . /workdir/.env
    set +a
fi

SW_TEST_URL="https://${SIGNALWIRE_SPACE}.signalwire.com/api/laml/2010-04-01/Accounts -u ${PROJECT_ID}:${REST_API_TOKEN}"
response_code=$(curl -s -o /dev/null -I -w "%{http_code}" $SW_TEST_URL )

# Define the output file
ENV_FILE="/workdir/.env"

if [[ $response_code -eq 200 ]]; then
    echo "INFO: SignalWire Credentials work âœ…"
elif [[ $response_code -eq 404 ]]; then
    echo "ERROR: SignalWire Space NOT FOUND ðŸ§"
    rm -f /workdir/.env
elif [[ $response_code -eq 401 ]]; then
    echo "ERROR: SignalWire Credentials DO NOT WORK ðŸ¤¨"
    rm -f /workdir/.env
elif [[ $response_code -eq 000 ]]; then
    echo "WARNING: Network unreachable, skipping validation âš ï¸"
    # Don't delete .env - network might just be down
else
    echo "WARNING: Unexpected response ($response_code), keeping credentials âš ï¸"
    # Don't delete .env for unknown errors - could be temporary
fi


if [ ! -f "/workdir/.env" ]; then
    # Display the form and collect the inputs
    {
	SIGNALWIRE_SPACE=$(whiptail --inputbox "Please enter your SignalWire Space Domain:" 8 78 --title "Input" 3>&1 1>&2 2>&3)
	exitstatus=$?
	if [ $exitstatus != 0 ]; then exit; fi

	PROJECT_ID=$(whiptail --inputbox "Please enter your Project ID:" 8 78 --title "Input" 3>&1 1>&2 2>&3)
	exitstatus=$?
	if [ $exitstatus != 0 ]; then exit; fi

	REST_API_TOKEN=$(whiptail --inputbox "Please enter your API Auth Token:" 8 78 --title "Input" 3>&1 1>&2 2>&3)
	exitstatus=$?
	if [ $exitstatus != 0 ]; then exit; fi

	NGROK_TOKEN=$(whiptail --inputbox "Please enter your NGROK Token:" 8 78 --title "Input" 3>&1 1>&2 2>&3)
	exitstatus=$?
	if [ $exitstatus != 0 ]; then exit; fi

	NGROK_ARGS=$(whiptail --inputbox "Please enter your NGROK Args:" 8 78 --title "Input" 3>&1 1>&2 2>&3)
	exitstatus=$?
	if [ $exitstatus != 0 ]; then exit; fi
    }

    # Dropdown for VISUAL using whiptail menu
    VISUAL=$(whiptail --title "Visual Editor Selection" --menu "Choose your editor" 15 60 3 \
		      "nano" "" \
		      "emacs" "" \
		      "vim" "" 3>&1 1>&2 2>&3)

    exitstatus=$?
    if [ $exitstatus != 0 ]; then exit; fi

    # Write to .env file (no quotes, no export - compatible with Docker --env-file)
    {
	echo "SIGNALWIRE_SPACE=$SIGNALWIRE_SPACE"
	echo "PROJECT_ID=$PROJECT_ID"
	echo "REST_API_TOKEN=$REST_API_TOKEN"
	echo "NGROK_TOKEN=$NGROK_TOKEN"
	echo "NGROK_ARGS=$NGROK_ARGS"
	echo "VISUAL=$VISUAL"
	echo "WORKDIR=/workdir"
    } > $ENV_FILE

    sed -i~ 's/\.signalwire.com//g' $ENV_FILE

    set -a
    source $ENV_FILE
    set +a

    # Confirmation message
    whiptail --title "Confirmation" --msgbox "Details saved to $ENV_FILE." 8 78

fi

# Wait for ngrok tunnel (started by start_services.sh)
if [ -n "$NGROK_TOKEN" ]; then
    NGROK_URL=$(curl -s http://127.0.0.1:4040/api/tunnels 2>/dev/null | jq -r '.tunnels[0].public_url' 2>/dev/null)

    if [ "$NGROK_URL" = "null" ] || [ -z "$NGROK_URL" ]; then
        echo "Waiting for ngrok tunnel..."
        RETRY_COUNT=0
        MAX_RETRIES=5

        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            sleep 2
            NGROK_URL=$(curl -s http://127.0.0.1:4040/api/tunnels 2>/dev/null | jq -r '.tunnels[0].public_url' 2>/dev/null)

            if [ "$NGROK_URL" != "null" ] && [ -n "$NGROK_URL" ]; then
                break
            fi
            RETRY_COUNT=$((RETRY_COUNT+1))
        done
    fi

    if [ -n "$NGROK_URL" ] && [ "$NGROK_URL" != "null" ]; then
        echo "ngrok tunnel: $NGROK_URL"
        export HOSTNAME=$(echo "$NGROK_URL" | sed 's/https:\/\///')
    else
        echo "ngrok tunnel not available"
        NGROK_URL=""
    fi
fi



# Update the phone numbers that were previously mapped to an ngrok URL
if [ ! -z "$NGROK_URL" ] && [ "$NGROK_URL" != "null" ]; then
    python3 /usr/lib/cgi-bin/update_laml_bins.py $NGROK_URL
fi

clear
echo -e "\n\n";
cat /.sw.ans
echo -e "\n\n";
echo -e "Welcome to WireStarter!";
echo -e "\n"

if [ -n "$NGROK_URL" ]; then
    echo -e "NGROK Tunnel: $NGROK_URL";
    echo -e "/workdir/public -> $NGROK_URL/public\n";
fi

if [ -n "$WORKDIR" ]; then
    echo -e "Persistent host directory is /workdir -> $WORKDIR\n";
fi

if [ -f "/workdir/.bashrc" ]; then
   . "/workdir/.bashrc"
fi

if [  -f "/workdir/.emacs" ]; then
    ln -f -s /workdir/.emacs ~/.emacs
fi

if [  -f "/workdir/.gitconfig" ]; then
    ln -f -s /workdir/.gitconfig ~
fi
if [ -f "/workdir/.pypirc" ]; then
    ln -f -s /workdir/.pypirc ~
fi

if [  -d "/workdir/.ssh" ]; then
    rm -rf ~/.ssh
    ln -f -s /workdir/.ssh ~
fi

# Claude Code config persistence
if [ -d "/workdir/.claude" ]; then
    rm -rf ~/.claude
    ln -f -s /workdir/.claude ~
else
    mkdir -p /workdir/.claude
    ln -f -s /workdir/.claude ~
fi

# Gemini CLI config persistence
if [ -d "/workdir/.gemini" ]; then
    rm -rf ~/.gemini
    ln -f -s /workdir/.gemini ~
else
    mkdir -p /workdir/.gemini
    ln -f -s /workdir/.gemini ~
fi

# Start PostgreSQL if previously configured via setup.sh
if [ -f "/workdir/.setuppgsql" ] && [ -d "/workdir/postgres" ]; then
    sudo -u postgres /usr/lib/postgresql/15/bin/pg_ctl -D /workdir/postgres -l /workdir/postgres/logfile start 2>/dev/null
fi

# GitHub Copilot config persistence (symlink instead of copy)
if [ -d "/workdir/github-copilot" ]; then
    mkdir -p ~/.config
    rm -rf ~/.config/github-copilot
    ln -f -s /workdir/github-copilot ~/.config/github-copilot
fi

if [  -f "/workdir/cpanfile" ]; then
    mkdir -p /workdir/perllib
    cpanm -l /workdir/perllib --installdeps /workdir/
    touch /.cpandone
    export PATH=/workdir/perllib/bin:$PATH
    export PERL5LIB=/workdir/perllib/lib/perl5:$PERL5LIB

    psql() {
	command psql -U postgres "$@"
    }
fi

# Common typos when using emacs, so things just work.
if [ "$VISUAL" = "emacs" ]; then
    alias e='emacs'
    alias eamcs='emacs'
    alias emcas='emacs'
    alias meacs='emacs'
    alias mecas='emacs'
fi

# Navigation aliases
alias ..='cd ..'
alias ...='cd ../..'
alias work='cd /workdir'
alias public='cd /workdir/public'

# Help command
help() {
    cat << 'HELPEOF'
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                         WireStarter Development Environment                   â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SETUP & STATUS
  setup                 Interactive environment setup (Go, NVM, PostgreSQL, npm)

NAVIGATION
  work                  cd /workdir
  public                cd /workdir/public
  ..                    cd ..
  ...                   cd ../..

PYTHON VIRTUAL ENVIRONMENTS (persistent in /workdir/.venvs/)
  venv init             Create and activate venv for current directory
  venv delete           Delete venv for current directory
  venv list             List all persistent venvs
  venv path             Show venv path for current directory
  venv nuke             Deactivate and delete currently active venv
  (auto-activates when cd'ing into /workdir/* directories with venvs)

PROJECT SCAFFOLDING
  newproject [name]     Create new Flask project with venv
  newagent [name]       Create new SignalWire agent project with venv

RUNNING APPS
  up [script]           Run Python script in loop (default: app.py), Ctrl+C to stop
  watch [script]        Run script, auto-restart on .py file changes
  serve [port]          Run Flask app on port (default: 5000)

PROCESS MANAGEMENT
  ports                 Show what's running on ports 5000, 5002, 9080
  killport <port>       Kill process on specified port
  reload                Reload nginx configuration

SIGNALWIRE
  sw_test               Test SignalWire API credentials
  sw_numbers            List SignalWire phone numbers
  swpy                  Python REPL with SignalWire client pre-loaded
  swsh                  SignalWire Shell (interactive CLI)

NETWORKING
  urls                  Show ngrok tunnel URLs (main app, public)
  tunnel                Print current ngrok URL
  testapp               Test local and public endpoints
  ngrok_url             Get raw ngrok URL

LOGS & DEBUGGING
  logs                  Tail nginx access log
  reqs                  Tail nginx access log (formatted)
  webhook               Start webhook catcher (dumps requests to console)
                        Available at $NGROK_URL/webhook
                        XML responses at $NGROK_URL/webhook/xml

REDIS
  redis                 Redis CLI
  rkeys                 List all Redis keys
  rget <key>            Get Redis value
  rclear                Flush all Redis data

GIT
  gs                    git status
  gd                    git diff
  gl                    git log --oneline -20
  gp                    git pull

AI ASSISTANTS
  claude                Claude Code CLI
  gemini                Gemini CLI

PERSISTENT STORAGE (survives container rebuilds)
  /workdir/.venvs/      Python virtual environments
  /workdir/.go/         Go installation
  /workdir/.nvm/        NVM + Node.js versions
  /workdir/.npm/        NPM cache
  /workdir/.claude/     Claude Code auth & config
  /workdir/.gemini/     Gemini CLI auth & config
  /workdir/.ssh/        SSH keys
  /workdir/postgres/    PostgreSQL data
  /workdir/public/      Static files (served at $NGROK_URL/public/)
  /workdir/.env         Environment variables

HELPEOF
}

alias h='help'

alias ngrok_url="curl -s http://127.0.0.1:4040/api/tunnels | jq -r '.tunnels[0].public_url'"

# Git shortcuts
alias gs='git status'
alias gd='git diff'
alias gl='git log --oneline -20'
alias gp='git pull'

# SignalWire development helpers
sw_test() {
    curl -s "https://${SIGNALWIRE_SPACE}.signalwire.com/api/laml/2010-04-01/Accounts" \
        -u "${PROJECT_ID}:${REST_API_TOKEN}" | jq .
}

sw_numbers() {
    curl -s "https://${SIGNALWIRE_SPACE}.signalwire.com/api/laml/2010-04-01/Accounts/${PROJECT_ID}/IncomingPhoneNumbers" \
        -u "${PROJECT_ID}:${REST_API_TOKEN}" | jq '.incoming_phone_numbers[] | {sid, phone_number, friendly_name}'
}

logs() {
    tail -f /var/log/nginx/access.log
}

urls() {
    echo "Main app:  ${NGROK_URL:-<not set>}/"
    echo "Webhook:   ${NGROK_URL:-<not set>}/webhook"
    echo "Public:    ${NGROK_URL:-<not set>}/public/"
}

# Process management
serve() {
    local port="${1:-5000}"
    if [ -f "./app.py" ]; then
        FLASK_APP=app.py flask run --host=0.0.0.0 --port="$port"
    else
        echo "No app.py found"
    fi
}

killport() {
    local port="$1"
    if [ -z "$port" ]; then
        echo "Usage: killport <port>"
        return 1
    fi
    fuser -k "$port/tcp" 2>/dev/null
    echo "Killed processes on port $port"
}

ports() {
    echo "Port 5000 (Flask app):"
    fuser 5000/tcp 2>/dev/null || echo "  (nothing)"
    echo "Port 5002 (Webhook):"
    fuser 5002/tcp 2>/dev/null || echo "  (nothing)"
    echo "Port 9080 (nginx):"
    fuser 9080/tcp 2>/dev/null || echo "  (nothing)"
}

# Project scaffolding
newproject() {
    local name="${1:-myproject}"
    mkdir -p "/workdir/$name"
    cd "/workdir/$name" || return
    venv init
    cat > app.py << 'APPEOF'
from flask import Flask
app = Flask(__name__)

@app.route('/')
def index():
    return 'Hello from WireStarter!'

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)
APPEOF
    echo "Created /workdir/$name with app.py"
    echo "Run 'up' to start the server"
}

# NVM setup (persistent in /workdir/.nvm)
export NVM_DIR="/workdir/.nvm"
if [ -f "$NVM_DIR/nvm.sh" ]; then
    source "$NVM_DIR/nvm.sh"
fi

# Go setup (persistent in /workdir/.go)
if [ -d "/workdir/.go" ]; then
    export PATH=/workdir/.go/bin:${PATH}
    export GOPATH=/workdir/.go
fi

# NPM cache persistence
if [ -d "/workdir/.npm" ]; then
    npm config set cache /workdir/.npm 2>/dev/null
fi

if [ -z $VISUAL ]; then
    export VISUAL=vim
fi

export PATH=$PATH:/usr/bin/nodejs.d:/usr/bin/perl.d:/usr/bin/python.d

if [ -n "$SIGNALWIRE_SPACE" ] && [ -n "$PROJECT_ID" ] && [ -n "$REST_API_TOKEN" ] && [ ! -f /workdir/.noswsh ]; then
    python3 /usr/local/bin/swsh
fi

# Persistent venv storage in /workdir/.venvs/
# Converts directory path to venv name: /workdir/myproject -> myproject
#                                       /workdir/foo/bar -> foo_bar

# Install packages with a spinner animation
_install_with_spinner() {
    local packages="$1"
    local spinner='|/-\'
    local i=0

    printf "Installing base packages... "

    # Disable job control messages
    set +m

    # Run pip install in background
    pip install $packages > /dev/null 2>&1 &
    local pid=$!

    # Show spinner while pip runs
    while kill -0 $pid 2>/dev/null; do
        printf "\b%c" "${spinner:i%4:1}"
        i=$((i+1))
        sleep 0.1
    done

    # Check exit status
    wait $pid 2>/dev/null
    local status=$?

    # Re-enable job control
    set -m

    if [ $status -eq 0 ]; then
        printf "\bdone\n"
    else
        printf "\bfailed\n"
    fi

    return $status
}

_get_venv_path() {
    local dir="${1:-$(pwd)}"
    # Strip /workdir/ prefix and replace / with _
    local venv_name=$(echo "$dir" | sed 's|^/workdir/||' | tr '/' '_')
    echo "/workdir/.venvs/${venv_name}"
}

_get_venv_for_pwd() {
    # Only auto-activate for directories under /workdir
    if [[ "$PWD" == /workdir/* ]]; then
        _get_venv_path "$PWD"
    fi
}

cd() {
    builtin cd "$@" || return

    local venv_path=$(_get_venv_for_pwd)

    if [ -n "$venv_path" ] && [ -d "$venv_path" ]; then
        # Activate if not already active
        if [ "$VIRTUAL_ENV" != "$venv_path" ]; then
            # Deactivate current venv first if any
            if [ -n "$VIRTUAL_ENV" ]; then
                deactivate 2>/dev/null
            fi
            source "$venv_path/bin/activate"
            echo "Activated venv: $venv_path"
        fi
    else
        # Deactivate if leaving a venv-enabled directory
        if [ -n "$VIRTUAL_ENV" ]; then
            deactivate
            echo "Deactivated venv"
        fi
    fi
}

venv() {
    local action="$1"
    local venv_path=$(_get_venv_path)

    # Ensure we're in /workdir
    if [[ "$PWD" != /workdir/* ]]; then
        echo "Error: venv only works in /workdir directories"
        return 1
    fi

    case "$action" in
        init)
            if [ -d "$venv_path" ]; then
                echo "Venv already exists: $venv_path"
                if [ "$VIRTUAL_ENV" != "$venv_path" ]; then
                    source "$venv_path/bin/activate"
                    echo "Activated venv"
                fi
            else
                mkdir -p /workdir/.venvs
                python3 -m venv "$venv_path"
                echo "Created venv: $venv_path"
                source "$venv_path/bin/activate"
                echo "Activated venv"
                # Install default packages with spinner
                _install_with_spinner "flask requests signalwire-agents"
                if [ -f "requirements.txt" ]; then
                    echo "Installing requirements.txt..."
                    pip install -r requirements.txt > /dev/null 2>&1
                fi
            fi
            ;;
        delete)
            if [ -d "$venv_path" ]; then
                echo "This will delete the venv for the CURRENT DIRECTORY:"
                echo "  $venv_path"
                read -p "Are you sure? (y/n): " confirm
                if [ "$confirm" = "y" ] || [ "$confirm" = "Y" ]; then
                    if [ "$VIRTUAL_ENV" = "$venv_path" ]; then
                        deactivate
                        echo "Deactivated venv"
                    fi
                    rm -rf "$venv_path"
                    echo "Deleted venv: $venv_path"
                else
                    echo "Cancelled"
                fi
            else
                echo "No venv found for this directory"
            fi
            ;;
        list)
            echo "Persistent venvs in /workdir/.venvs/:"
            ls -1 /workdir/.venvs/ 2>/dev/null || echo "  (none)"
            ;;
        path)
            echo "$venv_path"
            ;;
        nuke)
            if [ -n "$VIRTUAL_ENV" ]; then
                echo "This will delete the CURRENTLY ACTIVE venv:"
                echo "  $VIRTUAL_ENV"
                read -p "Are you sure? (y/n): " confirm
                if [ "$confirm" = "y" ] || [ "$confirm" = "Y" ]; then
                    local active_venv="$VIRTUAL_ENV"
                    deactivate
                    echo "Deactivated venv"
                    rm -rf "$active_venv"
                    echo "Deleted venv: $active_venv"
                else
                    echo "Cancelled"
                fi
            else
                echo "No active venv to nuke"
            fi
            ;;
        *)
            echo "Usage: venv [init|delete|list|path|nuke]"
            echo ""
            echo "Commands:"
            echo "  init   - Create and activate venv for current directory"
            echo "  delete - Delete venv for current directory"
            echo "  list   - List all persistent venvs"
            echo "  path   - Show venv path for current directory"
            echo "  nuke   - Deactivate and delete currently active venv"
            ;;
    esac
}

up() {
    local script="${1:-app.py}"
    if [ ! -f "./$script" ]; then
        echo "Error: $script not found in current directory."
        return 1
    fi

    echo "Starting $script (Ctrl+C to stop)..."
    trap 'echo " Stopped."; trap - INT; return 0' INT
    while true; do
        python3 "$script"
        local exit_code=$?
        echo "$script exited (code: $exit_code), restarting in 1s..."
        sleep 1
    done
}

# Reload nginx configuration
reload() {
    nginx -t && nginx -s reload && echo "nginx reloaded"
}

# Watch for file changes and auto-restart app
watch() {
    local script="${1:-app.py}"
    if [ ! -f "./$script" ]; then
        echo "Error: $script not found in current directory."
        return 1
    fi

    echo "Watching for changes (Ctrl+C to stop)..."
    trap 'kill $PID 2>/dev/null; echo " Stopped."; trap - INT; return 0' INT
    while true; do
        python3 "$script" &
        PID=$!
        inotifywait -q -e modify -r . --include '\.py$' 2>/dev/null
        kill $PID 2>/dev/null
        wait $PID 2>/dev/null
        echo "Change detected, restarting..."
        sleep 0.5
    done
}

# Redis helpers
alias redis='redis-cli'
rclear() { redis-cli FLUSHALL && echo "Redis flushed"; }
rkeys() { redis-cli KEYS '*'; }
rget() { redis-cli GET "$1"; }

# Get ngrok tunnel URL
tunnel() {
    local url=$(curl -s http://127.0.0.1:4040/api/tunnels | jq -r '.tunnels[0].public_url')
    echo "$url"
}

# Tail nginx access log with formatted output
reqs() {
    tail -f /var/log/nginx/access.log | awk '{print $4, $6, $7, $9}'
}

# Webhook catcher - dumps all incoming requests to console
webhook() {
    echo ""
    echo "Webhook URL: ${NGROK_URL:-http://localhost:9080}/webhook"
    echo "XML endpoint: ${NGROK_URL:-http://localhost:9080}/webhook/xml"
    echo ""
    python3 /usr/bin/webhook-catcher.py "${1:-5002}"
}

# Python REPL with SignalWire client pre-loaded
swpy() {
    python3 -i -c "
from signalwire.rest import Client
client = Client('$PROJECT_ID', '$REST_API_TOKEN', signalwire_space_url='$SIGNALWIRE_SPACE.signalwire.com')
print('SignalWire client ready as: client')
print('Example: client.incoming_phone_numbers.list()')
"
}

# Test app endpoints
testapp() {
    echo "Local (localhost:5000):"
    curl -s -o /dev/null -w "  Status: %{http_code}\n" "http://localhost:5000/" 2>/dev/null || echo "  Not running"
    if [ -n "$NGROK_URL" ]; then
        echo "Public ($NGROK_URL):"
        curl -s -o /dev/null -w "  Status: %{http_code}\n" "${NGROK_URL}/" 2>/dev/null || echo "  Not reachable"
    fi
}

# Create new SignalWire agent project with full structure
newagent() {
    local name="${1:-myagent}"
    local project_dir="/workdir/$name"

    if [ -d "$project_dir" ]; then
        echo "Directory $project_dir already exists"
        read -p "Overwrite? (y/n): " confirm
        [ "$confirm" != "y" ] && [ "$confirm" != "Y" ] && return
        rm -rf "$project_dir"
    fi

    echo "Creating SignalWire agent project: $name"

    # Create directory structure
    mkdir -p "$project_dir"/{agents,skills,tests,web}
    cd "$project_dir" || return

    # Initialize venv
    venv init

    # Create agents/__init__.py
    cat > agents/__init__.py << 'EOF'
from .main_agent import MainAgent

__all__ = ["MainAgent"]
EOF

    # Create main agent module
    cat > agents/main_agent.py << 'EOF'
#!/usr/bin/env python3
"""Main Agent - SignalWire AI Agent"""

import os
from signalwire_agents import AgentBase, SwaigFunctionResult


class MainAgent(AgentBase):
    """Main voice AI agent."""

    def __init__(self):
        super().__init__(
            name="main-agent",
            route="/",
            host="0.0.0.0",
            port=int(os.getenv("AGENT_PORT", "5000"))
        )

        self._configure_voice()
        self._configure_prompts()

    def _configure_voice(self):
        """Set up voice and language."""
        self.add_language("English", "en-US", "rime.spore")

        self.set_params({
            "end_of_speech_timeout": 500,
            "attention_timeout": 15000,
        })

    def _configure_prompts(self):
        """Set up AI prompts."""
        self.prompt_add_section(
            "Role",
            "You are a helpful AI assistant. "
            "Help callers with their questions and requests."
        )

        self.prompt_add_section(
            "Guidelines",
            body="Follow these guidelines:",
            bullets=[
                "Be professional and courteous",
                "Ask clarifying questions when needed",
                "Keep responses concise and helpful",
                "If you cannot help, offer to transfer to a human"
            ]
        )

    @AgentBase.tool(
        name="get_info",
        description="Get information about a topic",
        parameters={
            "type": "object",
            "properties": {
                "topic": {
                    "type": "string",
                    "description": "The topic to get information about"
                }
            },
            "required": ["topic"]
        }
    )
    def get_info(self, args, raw_data):
        """Get information about a topic."""
        topic = args.get("topic", "")
        # TODO: Implement your logic here
        return SwaigFunctionResult(f"Information about {topic}: This is a placeholder response.")

    def on_summary(self, summary):
        """Handle call summary."""
        print(f"Call summary: {summary}")


# Allow running directly for testing
if __name__ == "__main__":
    agent = MainAgent()
    agent.run()
EOF

    # Create main.py entry point
    cat > main.py << 'EOF'
#!/usr/bin/env python3
"""Main entry point for the agent server."""

import os
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

from agents import MainAgent


def main():
    agent = MainAgent()

    host = os.getenv("AGENT_HOST", "0.0.0.0")
    port = int(os.getenv("AGENT_PORT", "5000"))

    print(f"Starting agent on {host}:{port}")
    agent.run(host=host, port=port)


if __name__ == "__main__":
    main()
EOF

    # Create tests/__init__.py
    touch tests/__init__.py

    # Create test file
    cat > tests/test_agent.py << 'EOF'
#!/usr/bin/env python3
"""Tests for main agent."""

import pytest
from agents import MainAgent


class TestMainAgent:
    """Test main agent."""

    def setup_method(self):
        """Set up test fixtures."""
        self.agent = MainAgent()

    def test_agent_name(self):
        """Test agent has correct name."""
        assert self.agent.name == "main-agent"

    def test_has_functions(self):
        """Test agent has expected functions."""
        functions = self.agent._tool_registry.get_function_names()
        assert "get_info" in functions
EOF

    # Create .env.example
    cat > .env.example << 'EOF'
# Authentication (optional - SDK generates credentials if not set)
SWML_BASIC_AUTH_USER=
SWML_BASIC_AUTH_PASSWORD=

# Server Configuration
AGENT_HOST=0.0.0.0
AGENT_PORT=5000
SWML_PROXY_URL_BASE=

# Skill API Keys (as needed)
GOOGLE_API_KEY=
WEATHER_API_KEY=
EOF

    # Create .env from example
    cp .env.example .env

    # Create .gitignore
    cat > .gitignore << 'EOF'
# Virtual environment
venv/
.venv/
env/

# Environment variables
.env
.env.local
.env.*.local

# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
dist/
*.egg-info/

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# Testing
.pytest_cache/
.coverage
htmlcov/

# Logs
*.log

# OS
.DS_Store
Thumbs.db
EOF

    # Create requirements.txt
    cat > requirements.txt << 'EOF'
signalwire-agents>=1.0.3
python-dotenv>=1.0.0
pytest>=7.0.0
EOF

    # Create README.md
    cat > README.md << EOF
# $name

SignalWire AI Agent project.

## Setup

\`\`\`bash
# Activate virtual environment (auto-activated by WireStarter)
venv init

# Install additional dependencies
pip install -r requirements.txt

# Configure environment
cp .env.example .env
# Edit .env with your settings
\`\`\`

## Running

\`\`\`bash
# Run with auto-restart
up

# Or run directly
python main.py

# Test with swaig-test
swaig-test agents/main_agent.py --dump-swml
swaig-test agents/main_agent.py --list-tools
\`\`\`

## Testing

\`\`\`bash
pytest tests/ -v
\`\`\`

## Project Structure

\`\`\`
$name/
â”œâ”€â”€ agents/              # Agent modules
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ main_agent.py    # Main agent implementation
â”œâ”€â”€ skills/              # Custom skills (optional)
â”œâ”€â”€ tests/               # Test files
â”‚   â””â”€â”€ test_agent.py
â”œâ”€â”€ web/                 # Static files (optional)
â”œâ”€â”€ .env                 # Environment variables
â”œâ”€â”€ .env.example         # Environment template
â”œâ”€â”€ .gitignore
â”œâ”€â”€ main.py              # Entry point
â”œâ”€â”€ README.md
â””â”€â”€ requirements.txt
\`\`\`
EOF

    # Create sample web/index.html
    cat > web/index.html << 'EOF'
<!DOCTYPE html>
<html>
<head>
    <title>Agent Status</title>
    <style>
        body { font-family: system-ui, sans-serif; max-width: 600px; margin: 50px auto; padding: 20px; }
        .status { padding: 20px; background: #e8f5e9; border-radius: 8px; }
    </style>
</head>
<body>
    <h1>Agent Status</h1>
    <div class="status">
        <p><strong>Status:</strong> Running</p>
        <p><strong>Endpoint:</strong> /</p>
    </div>
</body>
</html>
EOF

    echo ""
    echo "Created SignalWire agent project: $project_dir"
    echo ""
    echo "Project structure:"
    echo "  agents/main_agent.py  - Main agent implementation"
    echo "  main.py               - Entry point"
    echo "  tests/test_agent.py   - Unit tests"
    echo "  .env                  - Environment variables"
    echo "  requirements.txt      - Dependencies"
    echo ""
    echo "Next steps:"
    echo "  1. Edit agents/main_agent.py to customize your agent"
    echo "  2. Run 'up' to start the agent"
    echo "  3. Test with: swaig-test agents/main_agent.py --dump-swml"
}

