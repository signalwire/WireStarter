# Persistent storage directory
PERSIST="/workdir/persistent"
mkdir -p "$PERSIST" 2>/dev/null

# Better history settings
export HISTFILE=$PERSIST/.bash_history
export HISTSIZE=10000
export HISTFILESIZE=20000
export HISTCONTROL=ignoredups:erasedups
shopt -s histappend

# Prompt helper functions (output raw text, no escapes)
__git_info() {
    local branch=$(git symbolic-ref --short HEAD 2>/dev/null)
    if [ -n "$branch" ]; then
        local status=""
        local rev=$(git rev-parse --short HEAD 2>/dev/null)
        # Check for uncommitted changes
        if ! git diff --quiet 2>/dev/null || ! git diff --cached --quiet 2>/dev/null; then
            status="*"
        fi
        # Check for untracked files
        if [ -n "$(git ls-files --others --exclude-standard 2>/dev/null)" ]; then
            status="${status}+"
        fi
        echo "${branch}:${rev}${status}"
    fi
}

__venv_info() {
    if [ -n "$VIRTUAL_ENV" ]; then
        basename "$VIRTUAL_ENV"
    fi
}

__short_pwd() {
    echo "$PWD"
}

__exit_status() {
    local code=$?
    if [ $code -ne 0 ]; then
        echo "$code"
    fi
}

# Build prompt using PROMPT_COMMAND to capture exit code, then set PS1
__build_prompt() {
    local EXIT=$?

    # Colors (raw escape codes for PROMPT_COMMAND context)
    local RST='\[\e[0m\]'
    local BOLD='\[\e[1m\]'
    local DIM='\[\e[2m\]'
    local RED='\[\e[31m\]'
    local GRN='\[\e[32m\]'
    local YLW='\[\e[33m\]'
    local BLU='\[\e[34m\]'
    local MAG='\[\e[35m\]'
    local CYN='\[\e[36m\]'

    # Get dynamic values
    local git_info=$(__git_info)
    local venv_info=$(__venv_info)
    local short_pwd=$(__short_pwd)

    # Start building PS1
    local PS1_LINE1=""
    local PS1_LINE2=""

    # Line 1: [exit] time path (git) [venv]
    PS1_LINE1="\n"

    # Exit code if non-zero
    if [ $EXIT -ne 0 ]; then
        PS1_LINE1+="${RED}[$EXIT]${RST} "
    fi

    # Time
    PS1_LINE1+="${DIM}\t${RST} "

    # Path
    PS1_LINE1+="${BOLD}${CYN}${short_pwd}${RST}"

    # Git info
    if [ -n "$git_info" ]; then
        PS1_LINE1+=" ${YLW}(${git_info})${RST}"
    fi

    # Venv info
    if [ -n "$venv_info" ]; then
        PS1_LINE1+=" ${MAG}[py:${venv_info}]${RST}"
    fi

    # Line 2: prompt character
    PS1_LINE2="\n${GRN}\$${RST} "

    PS1="${PS1_LINE1}${PS1_LINE2}"
}

PROMPT_COMMAND=__build_prompt

if [ -f "$PERSIST/.env" ]; then
    set -a
    . $PERSIST/.env
    set +a
fi

SW_TEST_URL="https://${SIGNALWIRE_SPACE_NAME}.signalwire.com/api/laml/2010-04-01/Accounts -u ${SIGNALWIRE_PROJECT_ID}:${SIGNALWIRE_TOKEN}"
response_code=$(curl -s -o /dev/null -I -w "%{http_code}" $SW_TEST_URL )

# Define the output file
ENV_FILE="$PERSIST/.env"

if [[ $response_code -eq 200 ]]; then
    echo "INFO: SignalWire Credentials work âœ…"
elif [[ $response_code -eq 404 ]]; then
    echo "ERROR: SignalWire Space NOT FOUND ðŸ§"
    rm -f $PERSIST/.env
elif [[ $response_code -eq 401 ]]; then
    echo "ERROR: SignalWire Credentials DO NOT WORK ðŸ¤¨"
    rm -f $PERSIST/.env
elif [[ $response_code -eq 000 ]]; then
    echo "WARNING: Network unreachable, skipping validation âš ï¸"
    # Don't delete .env - network might just be down
else
    echo "WARNING: Unexpected response ($response_code), keeping credentials âš ï¸"
    # Don't delete .env for unknown errors - could be temporary
fi


if [ ! -f "$PERSIST/.env" ]; then
    mkdir -p "$PERSIST"

    # Display the form and collect the inputs
    SIGNALWIRE_SPACE_NAME=$(whiptail --inputbox "SignalWire Space Name (required):" 8 60 --title "SignalWire Credentials" 3>&1 1>&2 2>&3)
    [ $? -ne 0 ] && exit

    SIGNALWIRE_PROJECT_ID=$(whiptail --inputbox "Project ID (required):" 8 60 --title "SignalWire Credentials" 3>&1 1>&2 2>&3)
    [ $? -ne 0 ] && exit

    SIGNALWIRE_TOKEN=$(whiptail --inputbox "SignalWire Token (required):" 8 60 --title "SignalWire Credentials" 3>&1 1>&2 2>&3)
    [ $? -ne 0 ] && exit

    NGROK_TOKEN=$(whiptail --inputbox "NGROK Token (required):" 8 60 --title "NGROK Setup" 3>&1 1>&2 2>&3)
    [ $? -ne 0 ] && exit

    NGROK_ARGS=$(whiptail --inputbox "NGROK Args (optional - e.g., --url yourdomain.ngrok.io):" 8 70 --title "Optional Settings" 3>&1 1>&2 2>&3)
    [ $? -ne 0 ] && exit

    FREESWITCH_PAT=$(whiptail --inputbox "FreeSWITCH PAT (optional):" 8 65 --title "Optional Settings" 3>&1 1>&2 2>&3)
    [ $? -ne 0 ] && exit

    VISUAL=$(whiptail --title "Default Editor" --menu "Choose your editor:" 14 50 5 \
        "vim" "Vi IMproved" \
        "emacs" "GNU Emacs" \
        "nano" "Simple editor" \
        "micro" "Modern terminal editor" \
        "ne" "Nice Editor" \
        3>&1 1>&2 2>&3)
    [ $? -ne 0 ] && exit

    # Strip .signalwire.com if included
    SIGNALWIRE_SPACE_NAME=$(echo "$SIGNALWIRE_SPACE_NAME" | sed 's/\.signalwire\.com//g')

    # Write .env file (quote values to handle special characters)
    cat > "$PERSIST/.env" << ENVEOF
SIGNALWIRE_SPACE_NAME="$SIGNALWIRE_SPACE_NAME"
SIGNALWIRE_PROJECT_ID="$SIGNALWIRE_PROJECT_ID"
SIGNALWIRE_TOKEN="$SIGNALWIRE_TOKEN"
NGROK_TOKEN="$NGROK_TOKEN"
NGROK_ARGS="$NGROK_ARGS"
FREESWITCH_PAT="$FREESWITCH_PAT"
VISUAL="$VISUAL"
WORKDIR="${WORKDIR:-/workdir}"
ENVEOF

    set -a
    source "$PERSIST/.env"
    set +a

    # Confirmation message
    whiptail --title "Confirmation" --msgbox "Details saved to $PERSIST/.env\n\nRun 'setup' for more options." 10 50

fi

# Restart services if their tmux sessions died
# ngrok
if [ -n "$NGROK_TOKEN" ] && ! tmux has-session -t ngrok 2>/dev/null; then
    echo "Restarting ngrok..."
    /usr/local/bin/ngrok config add-authtoken "$NGROK_TOKEN" > /dev/null 2>&1
    /usr/bin/tmux new-session -d -s ngrok "/usr/local/bin/ngrok http $NGROK_ARGS 9080"
    sleep 2
fi

# Cloudflare Tunnel
if [ -f "$PERSIST/.cloudflared/token" ] && ! tmux has-session -t cloudflared 2>/dev/null; then
    echo "Restarting Cloudflare Tunnel..."
    rm -rf ~/.cloudflared
    ln -sf "$PERSIST/.cloudflared" ~/.cloudflared
    /usr/bin/tmux new-session -d -s cloudflared "TUNNEL_TOKEN=\$(cat $PERSIST/.cloudflared/token) exec cloudflared tunnel run"
fi

# Webhook catcher
if ! tmux has-session -t webhook 2>/dev/null; then
    echo "Restarting webhook catcher..."
    mkdir -p "$PERSIST/logs"
    /usr/bin/tmux new-session -d -s webhook "python3 /usr/bin/webhook-catcher.py 5002 --log-file $PERSIST/logs/webhook.log"
fi

# Wait for ngrok tunnel (started by start_services.sh or restarted above)
if [ -n "$NGROK_TOKEN" ]; then
    NGROK_URL=$(curl -s http://127.0.0.1:4040/api/tunnels 2>/dev/null | jq -r '.tunnels[0].public_url' 2>/dev/null)

    if [ "$NGROK_URL" = "null" ] || [ -z "$NGROK_URL" ]; then
        echo "Waiting for ngrok tunnel..."
        RETRY_COUNT=0
        MAX_RETRIES=5

        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            sleep 2
            NGROK_URL=$(curl -s http://127.0.0.1:4040/api/tunnels 2>/dev/null | jq -r '.tunnels[0].public_url' 2>/dev/null)

            if [ "$NGROK_URL" != "null" ] && [ -n "$NGROK_URL" ]; then
                break
            fi
            RETRY_COUNT=$((RETRY_COUNT+1))
        done
    fi

    if [ -n "$NGROK_URL" ] && [ "$NGROK_URL" != "null" ]; then
        echo "ngrok tunnel: $NGROK_URL"
        export HOSTNAME=$(echo "$NGROK_URL" | sed 's/https:\/\///')
    else
        echo "ngrok tunnel not available"
        NGROK_URL=""
    fi
fi



clear
echo -e "\n\n";
cat /.sw.ans
echo -e "\n\n";
echo -e "Welcome to WireStarter!";
echo -e "\n"

if [ -n "$NGROK_URL" ]; then
    echo -e "NGROK Tunnel:  $NGROK_URL"
    echo -e "Public files:  $NGROK_URL/public/"
    echo -e "Webhook:       $NGROK_URL/webhook"
    echo -e ""
fi

if [ -n "$HOST_WORKDIR" ]; then
    echo -e "Workdir: $HOST_WORKDIR -> /workdir"
elif [ -n "$WORKDIR" ]; then
    echo -e "Workdir: /workdir"
fi

echo -e ""
echo -e "Commands: help | setup | swsh | webhook | urls"
echo -e ""

if [ -f "$PERSIST/.bashrc" ]; then
   . "$PERSIST/.bashrc"
fi

# PostgreSQL alias (server started by start_services.sh)
if [ -f "$PERSIST/postgres/PG_VERSION" ]; then
    alias psql='psql -U postgres'
fi

if [  -f "/workdir/cpanfile" ]; then
    mkdir -p /workdir/perllib
    cpanm -l /workdir/perllib --installdeps /workdir/
    touch /.cpandone
    export PATH=/workdir/perllib/bin:$PATH
    export PERL5LIB=/workdir/perllib/lib/perl5:$PERL5LIB
fi

# Common typos when using emacs, so things just work.
if [ "$VISUAL" = "emacs" ]; then
    alias e='emacs'
    alias eamcs='emacs'
    alias emcas='emacs'
    alias meacs='emacs'
    alias mecas='emacs'
fi

# Navigation aliases
alias ..='cd ..'
alias ...='cd ../..'
alias work='cd /workdir'
alias public='cd /workdir/persistent/public'

# Ollama - default to host.docker.internal if not set
if [ -z "$OLLAMA_HOST" ]; then
    export OLLAMA_HOST="http://host.docker.internal:11434"
fi

ollama_url() {
    echo "$OLLAMA_HOST"
    # Test connection
    if curl -s --connect-timeout 2 "$OLLAMA_HOST/api/tags" > /dev/null 2>&1; then
        echo "Status: Connected"
        echo "Models:"
        curl -s "$OLLAMA_HOST/api/tags" | jq -r '.models[].name' 2>/dev/null | sed 's/^/  /'
    else
        echo "Status: Not connected (is Ollama running on host?)"
    fi
}

# Help command
help() {
    cat << 'HELPEOF'
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                        WireStarter Development Environment                   â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SETUP & STATUS
  setup                 Interactive environment setup (Go, NVM, PostgreSQL, npm)

NAVIGATION
  work                  cd /workdir
  public                cd /workdir/persistent/public
  ..                    cd ..
  ...                   cd ../..

PYTHON VIRTUAL ENVIRONMENTS (persistent in /workdir/persistent/.venvs/)
  venv init             Create and activate venv for current directory
  venv delete           Delete venv for current directory
  venv list             List all persistent venvs
  venv path             Show venv path for current directory
  venv nuke             Deactivate and delete currently active venv
  venv audit            Find and remove orphaned venvs
  (auto-activates when cd'ing into /workdir/* directories with venvs)
  (auto-cleans orphaned venvs on shell startup)

PROJECT SCAFFOLDING
  newproject [name]     Create new Flask project with venv
  newagent [name]       Create SignalWire agent project with full structure
                        (agents/, skills/, tests/, web/, .env with credentials)

RUNNING APPS
  up [script]           Run Python script in loop (default: app.py), Ctrl+C to stop
  watch [script]        Run script, auto-restart on .py file changes
  serve [port]          Run Flask app on port (default: 5000)

PROCESS MANAGEMENT
  ports                 Show what's running on ports 5000, 5002, 9080
  killport <port>       Kill process on specified port
  reload                Reload nginx configuration

SIGNALWIRE
  sw_test               Test SignalWire API credentials
  sw_numbers            List SignalWire phone numbers
  swpy                  Python REPL with SignalWire client pre-loaded
  swsh                  SignalWire Shell (interactive CLI)

NETWORKING
  urls                  Show ngrok tunnel URLs (main app, public)
  tunnel                Print current ngrok URL
  testapp               Test local and public endpoints
  ngrok_url             Get raw ngrok URL

LOGS & DEBUGGING
  logs                  Tail nginx access log
  reqs                  Tail nginx access log (formatted)
  webhook               Tail webhook log (catcher runs in background)
  webhook clear         Clear webhook log
  webhook status        Show webhook catcher status
  webhook attach        Attach to webhook catcher tmux session
                        Webhook URLs: $NGROK_URL/webhook, $NGROK_URL/webhook/xml

REDIS
  redis                 Redis CLI
  rkeys                 List all Redis keys
  rget <key>            Get Redis value
  rclear                Flush all Redis data

GIT
  gs                    git status
  gd                    git diff
  gl                    git log --oneline -20
  gp                    git pull

AI ASSISTANTS
  claude                Claude Code CLI
  gemini                Gemini CLI
  ollama                Ollama CLI (connects to OLLAMA_HOST)
  ollama_url            Show Ollama host URL

PERSISTENT STORAGE (/workdir/persistent/ - survives container rebuilds)
  .venvs/               Python virtual environments
  .go/                  Go installation
  .nvm/                 NVM + Node.js versions
  .npm/                 NPM cache
  .claude/              Claude Code auth & config
  .gemini/              Gemini CLI auth & config
  .ssh/                 SSH keys
  postgres/             PostgreSQL data
  logs/                 Webhook and service logs
  .env                  Environment variables

  /workdir/persistent/public/  Static files (served at $NGROK_URL/public/)

HELPEOF
}

alias h='help'

alias ngrok_url="curl -s http://127.0.0.1:4040/api/tunnels | jq -r '.tunnels[0].public_url'"

# Git shortcuts
alias gs='git status'
alias gd='git diff'
alias gl='git log --oneline -20'
alias gp='git pull'

# SignalWire development helpers
sw_test() {
    curl -s "https://${SIGNALWIRE_SPACE_NAME}.signalwire.com/api/laml/2010-04-01/Accounts" \
        -u "${SIGNALWIRE_PROJECT_ID}:${SIGNALWIRE_TOKEN}" | jq .
}

sw_numbers() {
    curl -s "https://${SIGNALWIRE_SPACE_NAME}.signalwire.com/api/laml/2010-04-01/Accounts/${SIGNALWIRE_PROJECT_ID}/IncomingPhoneNumbers" \
        -u "${SIGNALWIRE_PROJECT_ID}:${SIGNALWIRE_TOKEN}" | jq '.incoming_phone_numbers[] | {sid, phone_number, friendly_name}'
}

logs() {
    tail -f /var/log/nginx/access.log
}

urls() {
    echo "Main app:  ${NGROK_URL:-<not set>}/"
    echo "Webhook:   ${NGROK_URL:-<not set>}/webhook"
    echo "Public:    ${NGROK_URL:-<not set>}/public/"
}

# Process management
serve() {
    local port="${1:-5000}"
    if [ -f "./app.py" ]; then
        FLASK_APP=app.py flask run --host=0.0.0.0 --port="$port"
    else
        echo "No app.py found"
    fi
}

killport() {
    local port="$1"
    if [ -z "$port" ]; then
        echo "Usage: killport <port>"
        return 1
    fi
    fuser -k "$port/tcp" 2>/dev/null
    echo "Killed processes on port $port"
}

ports() {
    echo "Port 5000 (Flask app):"
    fuser 5000/tcp 2>/dev/null || echo "  (nothing)"
    echo "Port 5002 (Webhook):"
    fuser 5002/tcp 2>/dev/null || echo "  (nothing)"
    echo "Port 9080 (nginx):"
    fuser 9080/tcp 2>/dev/null || echo "  (nothing)"
}

# Project scaffolding
newproject() {
    local name="${1:-myproject}"
    mkdir -p "/workdir/$name"
    cd "/workdir/$name" || return
    venv init
    cat > app.py << 'APPEOF'
from flask import Flask
app = Flask(__name__)

@app.route('/')
def index():
    return 'Hello from WireStarter!'

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)
APPEOF
    echo "Created /workdir/$name with app.py"
    echo "Run 'up' to start the server"
}

# NVM setup (persistent)
export NVM_DIR="$PERSIST/.nvm"
if [ -f "$NVM_DIR/nvm.sh" ]; then
    source "$NVM_DIR/nvm.sh" >/dev/null 2>&1
fi

# Go setup (persistent)
if [ -d "$PERSIST/.go" ]; then
    export PATH=$PERSIST/.go/bin:${PATH}
    export GOPATH=$PERSIST/.go
fi

if [ -z $VISUAL ]; then
    export VISUAL=vim
fi

# UV (Python package manager) - ensure tools bin is in PATH
export PATH=$PERSIST/.local/bin:$PATH:/usr/bin/nodejs.d:/usr/bin/perl.d:/usr/bin/python.d

if [ -n "$SIGNALWIRE_SPACE_NAME" ] && [ -n "$SIGNALWIRE_PROJECT_ID" ] && [ -n "$SIGNALWIRE_TOKEN" ] && [ ! -f $PERSIST/.noswsh ]; then
    python3 /usr/local/bin/swsh
fi

# Persistent venv storage in $PERSIST/.venvs/
# Converts directory path to venv name: /workdir/myproject -> myproject
#                                       /workdir/foo/bar -> foo_bar

# Install packages with a spinner animation
_install_with_spinner() {
    local packages="$1"
    local spinner='|/-\'
    local i=0

    printf "Installing base packages... "

    # Disable job control messages
    set +m

    # Run pip install in background
    pip install $packages > /dev/null 2>&1 &
    local pid=$!

    # Show spinner while pip runs
    while kill -0 $pid 2>/dev/null; do
        printf "\b%c" "${spinner:i%4:1}"
        i=$((i+1))
        sleep 0.1
    done

    # Check exit status
    wait $pid 2>/dev/null
    local status=$?

    # Re-enable job control
    set -m

    if [ $status -eq 0 ]; then
        printf "\bdone\n"
    else
        printf "\bfailed\n"
    fi

    return $status
}

_get_venv_path() {
    local dir="${1:-$(pwd)}"
    # Strip /workdir/ prefix and replace / with _
    local venv_name=$(echo "$dir" | sed 's|^/workdir/||' | tr '/' '_')
    echo "$PERSIST/.venvs/${venv_name}"
}

_get_venv_for_pwd() {
    # Only auto-activate for directories under /workdir
    if [[ "$PWD" == /workdir/* ]]; then
        _get_venv_path "$PWD"
    fi
}

# Audit venvs and remove orphaned ones (where source directory no longer exists)
_audit_venvs() {
    local venvs_dir="$PERSIST/.venvs"
    [ ! -d "$venvs_dir" ] && return 0

    local removed=0
    for venv_dir in "$venvs_dir"/*/; do
        [ ! -d "$venv_dir" ] && continue

        # Get venv name and convert back to path
        local venv_name=$(basename "$venv_dir")
        local source_path="/workdir/$(echo "$venv_name" | tr '_' '/')"

        # Check if source directory exists
        if [ ! -d "$source_path" ]; then
            rm -rf "$venv_dir"
            removed=$((removed + 1))
        fi
    done

    if [ $removed -gt 0 ]; then
        echo "Cleaned up $removed orphaned venv(s)"
    fi
}

# Run venv audit on shell startup (silently)
_audit_venvs >/dev/null 2>&1

cd() {
    builtin cd "$@" || return

    local venv_path=$(_get_venv_for_pwd)

    if [ -n "$venv_path" ] && [ -d "$venv_path" ]; then
        # Activate if not already active
        if [ "$VIRTUAL_ENV" != "$venv_path" ]; then
            # Deactivate current venv first if any
            if [ -n "$VIRTUAL_ENV" ]; then
                deactivate 2>/dev/null
            fi
            source "$venv_path/bin/activate"
            echo "Activated venv: $venv_path"
        fi
    else
        # Deactivate if leaving a venv-enabled directory
        if [ -n "$VIRTUAL_ENV" ]; then
            if type deactivate &>/dev/null; then
                deactivate
            else
                unset VIRTUAL_ENV
            fi
            echo "Deactivated venv"
        fi
    fi
}

venv() {
    local action="$1"
    local venv_path=$(_get_venv_path)

    case "$action" in
        init|delete|path)
            # These commands require being in /workdir
            if [[ "$PWD" != /workdir/* ]]; then
                echo "Error: venv $action only works in /workdir directories"
                return 1
            fi
            ;;&
        init)
            if [ -d "$venv_path" ]; then
                echo "Venv already exists: $venv_path"
                if [ "$VIRTUAL_ENV" != "$venv_path" ]; then
                    source "$venv_path/bin/activate"
                    echo "Activated venv"
                fi
            else
                mkdir -p $PERSIST/.venvs
                python3 -m venv "$venv_path"
                echo "Created venv: $venv_path"
                source "$venv_path/bin/activate"
                echo "Activated venv"
                # Install default packages with spinner
                _install_with_spinner "flask requests signalwire-agents"
                if [ -f "requirements.txt" ]; then
                    echo "Installing requirements.txt..."
                    pip install -r requirements.txt > /dev/null 2>&1
                fi
            fi
            ;;
        delete)
            if [ -d "$venv_path" ]; then
                echo "This will delete the venv for the CURRENT DIRECTORY:"
                echo "  $venv_path"
                read -p "Are you sure? (y/n): " confirm
                if [ "$confirm" = "y" ] || [ "$confirm" = "Y" ]; then
                    if [ "$VIRTUAL_ENV" = "$venv_path" ]; then
                        deactivate
                        echo "Deactivated venv"
                    fi
                    rm -rf "$venv_path"
                    echo "Deleted venv: $venv_path"
                else
                    echo "Cancelled"
                fi
            else
                echo "No venv found for this directory"
            fi
            ;;
        list)
            echo "Persistent venvs in $PERSIST/.venvs/:"
            ls -1 $PERSIST/.venvs/ 2>/dev/null || echo "  (none)"
            ;;
        path)
            echo "$venv_path"
            ;;
        nuke)
            if [ -n "$VIRTUAL_ENV" ]; then
                echo "This will delete the CURRENTLY ACTIVE venv:"
                echo "  $VIRTUAL_ENV"
                read -p "Are you sure? (y/n): " confirm
                if [ "$confirm" = "y" ] || [ "$confirm" = "Y" ]; then
                    local active_venv="$VIRTUAL_ENV"
                    deactivate
                    echo "Deactivated venv"
                    rm -rf "$active_venv"
                    echo "Deleted venv: $active_venv"
                else
                    echo "Cancelled"
                fi
            else
                echo "No active venv to nuke"
            fi
            ;;
        audit)
            echo "Auditing venvs for orphaned directories..."
            local venvs_dir="$PERSIST/.venvs"
            if [ ! -d "$venvs_dir" ]; then
                echo "No venvs directory found"
                return 0
            fi

            local orphaned=0
            local valid=0
            for venv_dir in "$venvs_dir"/*/; do
                [ ! -d "$venv_dir" ] && continue

                local venv_name=$(basename "$venv_dir")
                local source_path="/workdir/$(echo "$venv_name" | tr '_' '/')"

                if [ -d "$source_path" ]; then
                    echo "  [OK] $venv_name -> $source_path"
                    valid=$((valid + 1))
                else
                    echo "  [ORPHAN] $venv_name (missing: $source_path)"
                    orphaned=$((orphaned + 1))
                fi
            done

            echo ""
            echo "Found $valid valid, $orphaned orphaned"

            if [ $orphaned -gt 0 ]; then
                read -p "Remove orphaned venvs? (y/n): " confirm
                if [ "$confirm" = "y" ] || [ "$confirm" = "Y" ]; then
                    _audit_venvs
                    echo "Orphaned venvs removed"
                else
                    echo "Cancelled"
                fi
            fi
            ;;
        *)
            echo "Usage: venv [init|delete|list|path|nuke|audit]"
            echo ""
            echo "Commands:"
            echo "  init   - Create and activate venv for current directory"
            echo "  delete - Delete venv for current directory"
            echo "  list   - List all persistent venvs"
            echo "  path   - Show venv path for current directory"
            echo "  nuke   - Deactivate and delete currently active venv"
            echo "  audit  - Find and remove orphaned venvs"
            ;;
    esac
}

# Wrapper for rm to auto-clean venvs when removing /workdir directories
rm() {
    local has_rf=false
    local dirs_to_check=()

    # Parse args to find directories being removed with -rf or -r
    for arg in "$@"; do
        case "$arg" in
            -rf|-fr|-r) has_rf=true ;;
            -*) ;;  # Skip other flags
            *)
                # Check if it's a directory under /workdir
                if [ -d "$arg" ]; then
                    # Get absolute path
                    local abs_path
                    if [[ "$arg" = /* ]]; then
                        abs_path="$arg"
                    else
                        abs_path="$(cd "$(dirname "$arg")" 2>/dev/null && pwd)/$(basename "$arg")"
                    fi

                    if [[ "$abs_path" == /workdir/* ]] && [[ "$abs_path" != $PERSIST/.venvs* ]]; then
                        dirs_to_check+=("$abs_path")
                    fi
                fi
                ;;
        esac
    done

    # Run the actual rm command
    command rm "$@"
    local rm_status=$?

    # If rm succeeded and we had directories, clean up their venvs
    if [ $rm_status -eq 0 ] && [ ${#dirs_to_check[@]} -gt 0 ]; then
        for dir in "${dirs_to_check[@]}"; do
            # Only if directory was actually removed
            if [ ! -d "$dir" ]; then
                local venv_name=$(echo "$dir" | sed 's|^/workdir/||' | tr '/' '_')
                local venv_path="$PERSIST/.venvs/$venv_name"

                if [ -d "$venv_path" ]; then
                    command rm -rf "$venv_path"
                    echo "Cleaned up venv: $venv_name"
                fi
            fi
        done
    fi

    return $rm_status
}

up() {
    local script="${1:-app.py}"
    if [ ! -f "./$script" ]; then
        echo "Error: $script not found in current directory."
        return 1
    fi

    echo "Starting $script (Ctrl+C to stop)..."
    trap 'echo " Stopped."; trap - INT; return 0' INT
    while true; do
        python3 "$script"
        local exit_code=$?
        echo "$script exited (code: $exit_code), restarting in 1s..."
        sleep 1
    done
}

# Reload nginx configuration
reload() {
    nginx -t && nginx -s reload && echo "nginx reloaded"
}

# Watch for file changes and auto-restart app
watch() {
    local script="${1:-app.py}"
    if [ ! -f "./$script" ]; then
        echo "Error: $script not found in current directory."
        return 1
    fi

    echo "Watching for changes (Ctrl+C to stop)..."
    trap 'kill $PID 2>/dev/null; echo " Stopped."; trap - INT; return 0' INT
    while true; do
        python3 "$script" &
        PID=$!
        inotifywait -q -e modify -r . --include '\.py$' 2>/dev/null
        kill $PID 2>/dev/null
        wait $PID 2>/dev/null
        echo "Change detected, restarting..."
        sleep 0.5
    done
}

# Redis helpers
alias redis='redis-cli'
rclear() { redis-cli FLUSHALL && echo "Redis flushed"; }
rkeys() { redis-cli KEYS '*'; }
rget() { redis-cli GET "$1"; }

# Get ngrok tunnel URL
tunnel() {
    local url=$(curl -s http://127.0.0.1:4040/api/tunnels | jq -r '.tunnels[0].public_url')
    echo "$url"
}

# Tail nginx access log with formatted output
reqs() {
    tail -f /var/log/nginx/access.log | awk '{print $4, $6, $7, $9}'
}

# Webhook catcher - view captured webhook requests
# The catcher runs as a background service, logging to $PERSIST/logs/webhook.log
webhook() {
    local log_file="$PERSIST/logs/webhook.log"

    case "$1" in
        clear)
            # Truncate log and signal catcher to reopen
            > "$log_file"
            pkill -HUP -f "webhook-catcher.py" 2>/dev/null || true
            echo "Webhook log cleared"
            ;;
        attach)
            # Attach to the tmux session for debugging
            tmux attach -t webhook
            ;;
        status)
            # Show webhook catcher status
            if tmux has-session -t webhook 2>/dev/null; then
                echo "Webhook catcher: running"
            else
                echo "Webhook catcher: not running"
            fi
            echo "Log file: $log_file"
            if [ -f "$log_file" ]; then
                echo "Log size: $(du -h "$log_file" | cut -f1)"
            fi
            ;;
        *)
            # Default: show URLs and tail the log
            echo ""
            echo "Webhook URL: ${NGROK_URL:-http://localhost:9080}/webhook"
            echo "XML endpoint: ${NGROK_URL:-http://localhost:9080}/webhook/xml"
            echo ""
            echo "Commands: webhook clear | webhook attach | webhook status"
            echo "Press Ctrl+C to stop watching"
            echo ""
            tail -f "$log_file"
            ;;
    esac
}

# Python REPL with SignalWire client pre-loaded
swpy() {
    python3 -i -c "
from signalwire.rest import Client
client = Client('$SIGNALWIRE_PROJECT_ID', '$SIGNALWIRE_TOKEN', signalwire_space_url='$SIGNALWIRE_SPACE_NAME.signalwire.com')
print('SignalWire client ready as: client')
print('Example: client.incoming_phone_numbers.list()')
"
}

# Test app endpoints
testapp() {
    echo "Local (localhost:5000):"
    curl -s -o /dev/null -w "  Status: %{http_code}\n" "http://localhost:5000/" 2>/dev/null || echo "  Not running"
    if [ -n "$NGROK_URL" ]; then
        echo "Public ($NGROK_URL):"
        curl -s -o /dev/null -w "  Status: %{http_code}\n" "${NGROK_URL}/" 2>/dev/null || echo "  Not reachable"
    fi
}

# newagent is now a standalone script in /usr/bin/newagent
# Creates full project structure with credentials injection

