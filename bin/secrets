#!/bin/bash
# WireStarter Secrets Management
# Encrypts persistent directory secrets using git-crypt (simple files) and SOPS+age (JSON configs)
#
# Usage: secrets <command> [options]
#
# Commands:
#   init         Initialize encryption (generate keys, create configs)
#   unlock       Decrypt secrets for use
#   lock         Encrypt secrets for committing to git
#   status       Show encryption status
#   export-key   Export key for backup
#   import-key   Import key from backup

set -e

WORKDIR="/workdir"
PERSIST="$WORKDIR/persistent"
SECRETS_DIR="$WORKDIR/.secrets"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[OK]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Check if encryption is initialized
is_initialized() {
    [ -d "$SECRETS_DIR" ] && [ -f "$SECRETS_DIR/age-key.pub" ]
}

# Check if git-crypt is unlocked
is_unlocked() {
    cd "$WORKDIR"
    if [ -d .git ] && [ -d .git-crypt ]; then
        # git-crypt status returns 0 if unlocked, non-zero if locked or not initialized
        git-crypt status &>/dev/null 2>&1
        return $?
    fi
    return 1
}

# Get the age public key
get_public_key() {
    if [ -f "$SECRETS_DIR/age-key.pub" ]; then
        cat "$SECRETS_DIR/age-key.pub"
    fi
}

# Decrypt the age key (if passphrase-protected)
get_age_key_file() {
    if [ -f "$SECRETS_DIR/age-key.txt" ]; then
        # Plaintext key exists
        echo "$SECRETS_DIR/age-key.txt"
    elif [ -f "$SECRETS_DIR/age-key.txt.enc" ]; then
        # Passphrase-encrypted key - decrypt to temp file
        local tmp_key=$(mktemp)
        trap "rm -f $tmp_key" EXIT

        echo "Enter passphrase to unlock secrets:"
        if age -d -o "$tmp_key" "$SECRETS_DIR/age-key.txt.enc"; then
            echo "$tmp_key"
        else
            rm -f "$tmp_key"
            return 1
        fi
    else
        log_error "No age key found"
        return 1
    fi
}

# Initialize encryption
cmd_init() {
    if is_initialized; then
        log_warn "Encryption already initialized in $SECRETS_DIR"
        echo "Run 'secrets status' to see current state"
        return 0
    fi

    log_info "Initializing secrets encryption..."

    # Create secrets directory
    mkdir -p "$SECRETS_DIR"
    chmod 700 "$SECRETS_DIR"

    # Initialize git repo if needed
    cd "$WORKDIR"
    if [ ! -d .git ]; then
        log_info "Initializing git repository..."
        git init
    fi

    # Ask for key type
    echo ""
    echo "Choose key protection method:"
    echo "  1) Passphrase (more secure, manual unlock required)"
    echo "  2) Key file (auto-unlock, protect the file)"
    echo ""
    read -p "Selection [1]: " key_type
    key_type=${key_type:-1}

    # Generate age keypair
    log_info "Generating age keypair..."
    local keygen_output=$(age-keygen 2>&1)
    local private_key=$(echo "$keygen_output" | grep -v "^#")
    local public_key=$(echo "$keygen_output" | grep "^# public key:" | cut -d: -f2 | tr -d ' ')

    # Save public key (safe to commit)
    echo "$public_key" > "$SECRETS_DIR/age-key.pub"

    if [ "$key_type" = "1" ]; then
        # Passphrase-protected
        echo ""
        echo "Enter a passphrase (minimum 12 characters):"
        while true; do
            read -s -p "Passphrase: " passphrase
            echo ""
            if [ ${#passphrase} -lt 12 ]; then
                log_error "Passphrase must be at least 12 characters"
                continue
            fi
            read -s -p "Confirm passphrase: " passphrase2
            echo ""
            if [ "$passphrase" != "$passphrase2" ]; then
                log_error "Passphrases don't match"
                continue
            fi
            break
        done

        # Encrypt private key with passphrase
        echo "$private_key" | age -p -o "$SECRETS_DIR/age-key.txt.enc" 2>/dev/null <<< "$passphrase"
        log_success "Private key encrypted with passphrase"

        # Also save plaintext temporarily for init (will be cleaned up)
        echo "$private_key" > "$SECRETS_DIR/age-key.txt"
        chmod 600 "$SECRETS_DIR/age-key.txt"
    else
        # Plain key file
        echo "$private_key" > "$SECRETS_DIR/age-key.txt"
        chmod 600 "$SECRETS_DIR/age-key.txt"
        log_success "Private key saved to $SECRETS_DIR/age-key.txt"
        log_warn "IMPORTANT: Protect this file! Anyone with it can decrypt your secrets."
    fi

    # Initialize git-crypt
    log_info "Initializing git-crypt..."
    git-crypt init

    # Export git-crypt key and encrypt with age
    git-crypt export-key /tmp/git-crypt.key
    age -r "$public_key" -o "$SECRETS_DIR/git-crypt.key.age" /tmp/git-crypt.key
    rm -f /tmp/git-crypt.key
    log_success "git-crypt key encrypted with age"

    # Create .gitattributes
    log_info "Creating .gitattributes..."
    cat > "$WORKDIR/.gitattributes" << 'GITATTR'
# WireStarter encrypted secrets (git-crypt)
# All sensitive files are transparently encrypted on commit

# Core credentials
persistent/.env filter=git-crypt diff=git-crypt
persistent/.env.* filter=git-crypt diff=git-crypt

# Cloud tunnel
persistent/.cloudflared/token filter=git-crypt diff=git-crypt

# AWS credentials
persistent/.aws/credentials filter=git-crypt diff=git-crypt
persistent/.aws/config filter=git-crypt diff=git-crypt

# Azure credentials
persistent/.azure/** filter=git-crypt diff=git-crypt

# GCloud credentials
persistent/.config/gcloud/application_default_credentials.json filter=git-crypt diff=git-crypt
persistent/.config/gcloud/credentials.db filter=git-crypt diff=git-crypt
persistent/.config/gcloud/access_tokens.db filter=git-crypt diff=git-crypt

# AI assistant credentials
persistent/.claude.json filter=git-crypt diff=git-crypt
persistent/.claude.json.backup filter=git-crypt diff=git-crypt
persistent/.claude/** filter=git-crypt diff=git-crypt
persistent/.gemini/** filter=git-crypt diff=git-crypt
persistent/.codex/** filter=git-crypt diff=git-crypt

# Package manager credentials
persistent/.npmrc filter=git-crypt diff=git-crypt
persistent/.pypirc filter=git-crypt diff=git-crypt
persistent/.git-credentials filter=git-crypt diff=git-crypt
persistent/.gitconfig filter=git-crypt diff=git-crypt

# Keep these readable (not encrypted)
.gitattributes !filter !diff
.gitignore !filter !diff
.sops.yaml !filter !diff
README.md !filter !diff
GITATTR

    # Create .sops.yaml
    log_info "Creating .sops.yaml..."
    cat > "$WORKDIR/.sops.yaml" << SOPSYAML
# WireStarter SOPS configuration
# JSON/YAML files - structured encryption (keys visible, values encrypted)
creation_rules:
  # Claude configs - encrypt sensitive values only
  - path_regex: persistent/\.claude.*\.json\$
    age: $public_key
    encrypted_regex: "^(claudeAiOauth|accessToken|refreshToken|apiKey|oauthAccount).*"

  # Gemini configs
  - path_regex: persistent/\.gemini/.*\.json\$
    age: $public_key
    encrypted_regex: "^(access_token|refresh_token|client_secret)$"

  # GCloud service accounts
  - path_regex: persistent/\.config/gcloud/.*\.json\$
    age: $public_key
    encrypted_regex: "^(private_key|private_key_id|client_secret)$"

  # Azure configs
  - path_regex: persistent/\.azure/.*\.json\$
    age: $public_key
    encrypted_regex: "^(accessToken|refreshToken|secret)$"

  # Codex configs
  - path_regex: persistent/\.codex/.*\.json\$
    age: $public_key
    encrypted_regex: "^(apiKey|api_key|token)$"
SOPSYAML

    # Create comprehensive .gitignore
    log_info "Creating .gitignore..."
    cat > "$WORKDIR/.gitignore" << 'GITIGNORE'
# WireStarter Meta-Repo .gitignore
# Secrets management
.secrets/age-key.txt
.secrets/recovery/
*.key
*.pem

# SSH keys (never commit)
persistent/.ssh/

# History files
persistent/.bash_history
persistent/.swsh_history

# Database
persistent/postgres/

# Logs
persistent/logs/

# Caches
persistent/.cache/
persistent/.npm/
persistent/.local/

# Development tools (large, reinstallable)
persistent/.venvs/
persistent/.go/
persistent/.nvm/

# Editor configs (personal preference)
persistent/.vim/
persistent/.emacs.d/

# Temp files
*.tmp
*.swp
*~
GITIGNORE

    # Set SOPS environment
    export SOPS_AGE_KEY_FILE="$SECRETS_DIR/age-key.txt"

    # Clean up plaintext key if using passphrase mode
    if [ "$key_type" = "1" ]; then
        rm -f "$SECRETS_DIR/age-key.txt"
        log_info "Plaintext key removed (passphrase mode)"
    fi

    echo ""
    log_success "Encryption initialized!"
    echo ""
    echo "Your public key (safe to share):"
    echo "  $public_key"
    echo ""
    echo "Next steps:"
    echo "  1. Run 'secrets unlock' to decrypt existing secrets"
    echo "  2. Add and commit your files: git add -A && git commit"
    echo "  3. Run 'secrets lock' before pushing to encrypt"
    echo ""
    if [ "$key_type" = "1" ]; then
        echo "IMPORTANT: Remember your passphrase! Without it, secrets cannot be recovered."
    else
        echo "IMPORTANT: Back up $SECRETS_DIR/age-key.txt securely!"
    fi
}

# Unlock secrets
cmd_unlock() {
    local quiet=false
    [ "$1" = "--quiet" ] || [ "$1" = "-q" ] && quiet=true

    if ! is_initialized; then
        $quiet || log_error "Encryption not initialized. Run 'secrets init' first."
        return 1
    fi

    cd "$WORKDIR"

    # Get the age key file
    local age_key
    if [ -f "$SECRETS_DIR/age-key.txt" ]; then
        age_key="$SECRETS_DIR/age-key.txt"
    elif [ -f "$SECRETS_DIR/age-key.txt.enc" ]; then
        # Need to decrypt the key
        if $quiet; then
            return 1  # Can't prompt in quiet mode
        fi

        local tmp_key=$(mktemp)
        echo "Enter passphrase to unlock secrets:"
        if ! age -d -o "$tmp_key" "$SECRETS_DIR/age-key.txt.enc" 2>/dev/null; then
            rm -f "$tmp_key"
            log_error "Failed to decrypt key. Wrong passphrase?"
            return 1
        fi
        age_key="$tmp_key"

        # Keep the decrypted key for the session
        cp "$tmp_key" "$SECRETS_DIR/age-key.txt"
        chmod 600 "$SECRETS_DIR/age-key.txt"
        rm -f "$tmp_key"
        age_key="$SECRETS_DIR/age-key.txt"

        $quiet || log_info "Key decrypted for this session"
    else
        $quiet || log_error "No age key found"
        return 1
    fi

    # Unlock git-crypt
    if [ -d .git-crypt ]; then
        # Decrypt git-crypt key with age
        local gc_key=$(mktemp)
        if age -d -i "$age_key" -o "$gc_key" "$SECRETS_DIR/git-crypt.key.age" 2>/dev/null; then
            if git-crypt unlock "$gc_key" 2>/dev/null; then
                $quiet || log_success "git-crypt unlocked"
            else
                $quiet || log_warn "git-crypt already unlocked or no encrypted files"
            fi
        else
            $quiet || log_error "Failed to decrypt git-crypt key"
        fi
        rm -f "$gc_key"
    fi

    # Export SOPS key for the session
    export SOPS_AGE_KEY_FILE="$age_key"

    $quiet || echo ""
    $quiet || log_success "Secrets unlocked! You can now access encrypted files."
    $quiet || echo "Tip: Edit JSON configs with 'sops <file>' for automatic encrypt/decrypt"
}

# Lock secrets
cmd_lock() {
    if ! is_initialized; then
        log_error "Encryption not initialized. Run 'secrets init' first."
        return 1
    fi

    cd "$WORKDIR"

    # Lock git-crypt
    if [ -d .git-crypt ]; then
        git-crypt lock 2>/dev/null || true
        log_success "git-crypt locked"
    fi

    # Check for passphrase mode - clean up plaintext key
    if [ -f "$SECRETS_DIR/age-key.txt.enc" ] && [ -f "$SECRETS_DIR/age-key.txt" ]; then
        rm -f "$SECRETS_DIR/age-key.txt"
        log_info "Plaintext key cleaned up (passphrase mode)"
    fi

    unset SOPS_AGE_KEY_FILE

    echo ""
    log_success "Secrets locked! Encrypted files are now opaque."
    echo "Run 'secrets unlock' to decrypt again."
}

# Show status
cmd_status() {
    echo "=== WireStarter Secrets Status ==="
    echo ""

    if ! is_initialized; then
        echo "Status: NOT INITIALIZED"
        echo ""
        echo "Run 'secrets init' to set up encryption."
        return 0
    fi

    echo "Status: INITIALIZED"
    echo ""

    # Key info
    echo "Key Management:"
    if [ -f "$SECRETS_DIR/age-key.txt" ]; then
        echo "  Mode: Key file (auto-unlock enabled)"
        echo "  Key:  $SECRETS_DIR/age-key.txt"
    elif [ -f "$SECRETS_DIR/age-key.txt.enc" ]; then
        echo "  Mode: Passphrase (manual unlock required)"
        echo "  Key:  $SECRETS_DIR/age-key.txt.enc (encrypted)"
    fi

    if [ -f "$SECRETS_DIR/age-key.pub" ]; then
        echo "  Public: $(cat $SECRETS_DIR/age-key.pub)"
    fi
    echo ""

    # git-crypt status
    cd "$WORKDIR"
    echo "git-crypt:"
    if [ -d .git-crypt ]; then
        if is_unlocked; then
            echo "  Status: UNLOCKED (files readable)"
        else
            echo "  Status: LOCKED (files encrypted)"
        fi

        # Count encrypted files
        local encrypted_count=$(git-crypt status 2>/dev/null | grep -c "encrypted:" || echo "0")
        local not_encrypted=$(git-crypt status 2>/dev/null | grep -c "not encrypted:" || echo "0")
        echo "  Encrypted files: $encrypted_count"
        echo "  Plaintext files: $not_encrypted"
    else
        echo "  Status: Not configured"
    fi
    echo ""

    # SOPS status
    echo "SOPS:"
    if [ -f "$WORKDIR/.sops.yaml" ]; then
        echo "  Config: $WORKDIR/.sops.yaml"
        if [ -n "$SOPS_AGE_KEY_FILE" ] && [ -f "$SOPS_AGE_KEY_FILE" ]; then
            echo "  Status: Ready (key loaded)"
        else
            echo "  Status: Key not loaded (run 'secrets unlock')"
        fi
    else
        echo "  Status: Not configured"
    fi
    echo ""

    # Sensitive files
    echo "Sensitive files in persistent/:"
    for f in .env .cloudflared/token .aws/credentials .ssh/id_ed25519 .claude.json .gemini/oauth_creds.json; do
        if [ -f "$PERSIST/$f" ]; then
            echo "  [*] $f"
        fi
    done
}

# Export key for backup
cmd_export_key() {
    if ! is_initialized; then
        log_error "Encryption not initialized."
        return 1
    fi

    local output="${1:-/tmp/wirestarter-key-backup}"
    mkdir -p "$output"

    # Need to unlock first if passphrase mode
    local age_key="$SECRETS_DIR/age-key.txt"
    if [ ! -f "$age_key" ] && [ -f "$SECRETS_DIR/age-key.txt.enc" ]; then
        echo "Enter passphrase to export key:"
        local tmp_key=$(mktemp)
        if ! age -d -o "$tmp_key" "$SECRETS_DIR/age-key.txt.enc" 2>/dev/null; then
            rm -f "$tmp_key"
            log_error "Failed to decrypt key"
            return 1
        fi
        age_key="$tmp_key"
    fi

    # Copy key files
    cp "$age_key" "$output/age-key.txt"
    cp "$SECRETS_DIR/age-key.pub" "$output/age-key.pub"

    # Also export git-crypt key
    age -d -i "$age_key" -o "$output/git-crypt.key" "$SECRETS_DIR/git-crypt.key.age"

    chmod 600 "$output"/*

    # Clean up temp key if used
    [ "$age_key" != "$SECRETS_DIR/age-key.txt" ] && rm -f "$age_key"

    echo ""
    log_success "Keys exported to: $output"
    echo ""
    echo "Files exported:"
    ls -la "$output"
    echo ""
    log_warn "IMPORTANT: Store these files securely and delete from this location!"
    echo "Without these keys, your encrypted secrets cannot be recovered."
}

# Import key from backup
cmd_import_key() {
    local input="$1"

    if [ -z "$input" ]; then
        echo "Usage: secrets import-key <backup-directory-or-key-file>"
        return 1
    fi

    if [ -d "$input" ]; then
        # Directory containing backup
        if [ ! -f "$input/age-key.txt" ]; then
            log_error "No age-key.txt found in $input"
            return 1
        fi

        mkdir -p "$SECRETS_DIR"
        cp "$input/age-key.txt" "$SECRETS_DIR/age-key.txt"
        cp "$input/age-key.pub" "$SECRETS_DIR/age-key.pub" 2>/dev/null || true

        if [ -f "$input/git-crypt.key" ]; then
            # Re-encrypt git-crypt key with age
            local pub_key=$(cat "$SECRETS_DIR/age-key.pub" 2>/dev/null || grep "^# public key:" "$SECRETS_DIR/age-key.txt" | cut -d: -f2 | tr -d ' ')
            age -r "$pub_key" -o "$SECRETS_DIR/git-crypt.key.age" "$input/git-crypt.key"
        fi

        chmod 600 "$SECRETS_DIR"/*

    elif [ -f "$input" ]; then
        # Single key file
        mkdir -p "$SECRETS_DIR"
        cp "$input" "$SECRETS_DIR/age-key.txt"
        chmod 600 "$SECRETS_DIR/age-key.txt"

        # Extract public key
        grep "^# public key:" "$input" | cut -d: -f2 | tr -d ' ' > "$SECRETS_DIR/age-key.pub"
    else
        log_error "Path not found: $input"
        return 1
    fi

    log_success "Key imported successfully"
    echo "Run 'secrets unlock' to decrypt your secrets."
}

# Main command dispatcher
case "${1:-}" in
    init)
        cmd_init
        ;;
    unlock)
        cmd_unlock "$2"
        ;;
    lock)
        cmd_lock
        ;;
    status)
        cmd_status
        ;;
    export-key|export)
        cmd_export_key "$2"
        ;;
    import-key|import)
        cmd_import_key "$2"
        ;;
    help|--help|-h|"")
        cat << 'HELP'
WireStarter Secrets Management

Encrypt your persistent directory secrets for safe version control.
Uses git-crypt for simple files and SOPS+age for JSON configs.

Usage: secrets <command> [options]

Commands:
  init           Initialize encryption (generate keys, create configs)
  unlock         Decrypt secrets for use (required after clone/pull)
  lock           Encrypt secrets for committing to git
  status         Show encryption status
  export-key     Export key for backup
  import-key     Import key from backup

Examples:
  secrets init              # First-time setup
  secrets unlock            # Start of session
  secrets lock              # Before git commit/push
  sops persistent/.claude.json  # Edit JSON config (auto-decrypt/encrypt)

For JSON configs, use 'sops <file>' to edit - it handles decryption automatically.
HELP
        ;;
    *)
        log_error "Unknown command: $1"
        echo "Run 'secrets help' for usage information."
        exit 1
        ;;
esac
