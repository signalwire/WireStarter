#!/bin/bash
# WireStarter Environment Setup

# Set TERM if not set (needed for whiptail)
export TERM="${TERM:-xterm}"

# Load existing .env if present
if [ -f "/workdir/.env" ]; then
    set -a
    . /workdir/.env 2>/dev/null || true
    set +a
fi

# Show loading screen with spinner while running a command
# Usage: show_loading "Title" "Message" command args...
show_loading() {
    local title="$1"
    local message="$2"
    shift 2

    # Start the command in background
    "$@" &
    local pid=$!

    # Show spinner using whiptail infobox in a loop
    local spinner='|/-\'
    local i=0
    while kill -0 $pid 2>/dev/null; do
        local spin_char="${spinner:i%4:1}"
        whiptail --title "$title" --infobox "$message $spin_char" 7 50
        sleep 0.2
        i=$((i+1))
    done

    wait $pid
    return $?
}

# Quick loading screen (just shows message, no command)
# Usage: loading_screen "Title" "Message" seconds
loading_screen() {
    local title="$1"
    local message="$2"
    local duration="${3:-1}"

    local spinner='|/-\'
    local i=0
    local end=$((SECONDS + duration))
    while [ $SECONDS -lt $end ]; do
        local spin_char="${spinner:i%4:1}"
        whiptail --title "$title" --infobox "$message $spin_char" 7 50
        sleep 0.2
        i=$((i+1))
    done
}

# Run command with whiptail progress gauge
run_with_progress() {
    local title="$1"
    local message="$2"
    shift 2

    # Run command in background and show gauge
    (
        echo 10
        "$@" > /tmp/setup_output.log 2>&1
        echo 100
    ) | whiptail --title "$title" --gauge "$message" 8 60 0

    return ${PIPESTATUS[0]}
}

# Start ngrok tunnel (matches start_services.sh)
start_ngrok() {
    if [ -z "$NGROK_TOKEN" ]; then
        whiptail --title "ngrok" --msgbox "NGROK_TOKEN not set.\n\nPlease run 'Setup SignalWire & NGROK Credentials' first." 10 55
        return 1
    fi

    # Check if ngrok is already running
    if curl -s http://127.0.0.1:4040/api/tunnels > /dev/null 2>&1; then
        local existing_url=$(curl -s http://127.0.0.1:4040/api/tunnels | jq -r '.tunnels[0].public_url')
        whiptail --title "ngrok" --msgbox "ngrok is already running!\n\nTunnel: $existing_url" 10 60
        export NGROK_URL="$existing_url"
        return 0
    fi

    # Start ngrok with progress
    (
        echo 10
        echo "XXX"
        echo "Configuring ngrok token..."
        echo "XXX"
        /usr/local/bin/ngrok config add-authtoken "$NGROK_TOKEN" > /dev/null 2>&1

        echo 30
        echo "XXX"
        echo "Starting ngrok tunnel..."
        echo "XXX"
        /usr/bin/screen -dmS ngrok /usr/local/bin/ngrok http $NGROK_ARGS 9080

        # Wait for ngrok to be ready
        retry=0
        while [ $retry -lt 10 ]; do
            sleep 2
            url=$(curl -s http://127.0.0.1:4040/api/tunnels 2>/dev/null | jq -r '.tunnels[0].public_url' 2>/dev/null)
            if [ -n "$url" ] && [ "$url" != "null" ]; then
                echo "$url" > /tmp/ngrok_url.txt
                echo 100
                exit 0
            fi
            retry=$((retry + 1))
            progress=$((30 + retry * 7))
            echo $progress
            echo "XXX"
            echo "Waiting for tunnel... ($retry/10)"
            echo "XXX"
        done
        echo 100
        exit 1
    ) | whiptail --title "Starting ngrok" --gauge "Initializing..." 8 60 0

    # Check result
    if [ -f /tmp/ngrok_url.txt ]; then
        export NGROK_URL=$(cat /tmp/ngrok_url.txt)
        export HOSTNAME=$(echo "$NGROK_URL" | sed 's|https://||')
        rm -f /tmp/ngrok_url.txt
        whiptail --title "ngrok Started" --msgbox "Tunnel ready!\n\n$NGROK_URL" 10 60
        return 0
    else
        whiptail --title "ngrok Failed" --msgbox "Failed to start ngrok tunnel.\n\nCheck your token and try again." 10 50
        return 1
    fi
}

setup_credentials() {
    # Reload .env to get latest values (in case file was modified externally)
    # Use a safer method that handles both quoted and unquoted values
    local sw_space="" project_id="" api_token="" freeswitch_pat="" ngrok_token="" ngrok_args="" visual="vim"
    if [ -f "/workdir/.env" ]; then
        # Parse each line manually to handle unquoted values with spaces
        while IFS= read -r line || [ -n "$line" ]; do
            # Skip comments and empty lines
            [[ "$line" =~ ^[[:space:]]*# ]] && continue
            [[ -z "$line" ]] && continue
            # Extract key and value, stripping quotes if present
            if [[ "$line" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*) ]]; then
                local key="${BASH_REMATCH[1]}"
                local val="${BASH_REMATCH[2]}"
                # Remove surrounding quotes if present
                val="${val#\"}" ; val="${val%\"}"
                val="${val#\'}" ; val="${val%\'}"
                case "$key" in
                    SIGNALWIRE_SPACE_NAME) sw_space="$val" ;;
                    SIGNALWIRE_PROJECT_ID) project_id="$val" ;;
                    SIGNALWIRE_TOKEN) api_token="$val" ;;
                    FREESWITCH_PAT) freeswitch_pat="$val" ;;
                    NGROK_TOKEN) ngrok_token="$val" ;;
                    NGROK_ARGS) ngrok_args="$val" ;;
                    VISUAL) visual="$val" ;;
                esac
            fi
        done < /workdir/.env
    fi

    # Fall back to environment if not found in file
    sw_space="${sw_space:-${SIGNALWIRE_SPACE_NAME:-}}"
    project_id="${project_id:-${SIGNALWIRE_PROJECT_ID:-}}"
    api_token="${api_token:-${SIGNALWIRE_TOKEN:-}}"
    freeswitch_pat="${freeswitch_pat:-${FREESWITCH_PAT:-}}"
    ngrok_token="${ngrok_token:-${NGROK_TOKEN:-}}"
    ngrok_args="${ngrok_args:-${NGROK_ARGS:-}}"
    visual="${visual:-vim}"

    sw_space=$(whiptail --inputbox "SignalWire Space Domain:" 8 60 "$sw_space" --title "SignalWire Credentials" 3>&1 1>&2 2>&3)
    [ $? -ne 0 ] && return

    project_id=$(whiptail --inputbox "Project ID:" 8 60 "$project_id" --title "SignalWire Credentials" 3>&1 1>&2 2>&3)
    [ $? -ne 0 ] && return

    api_token=$(whiptail --inputbox "SignalWire Token:" 8 60 "$api_token" --title "SignalWire Credentials" 3>&1 1>&2 2>&3)
    [ $? -ne 0 ] && return

    freeswitch_pat=$(whiptail --inputbox "FreeSWITCH PAT (optional):" 8 60 "$freeswitch_pat" --title "FreeSWITCH Credentials" 3>&1 1>&2 2>&3)
    [ $? -ne 0 ] && return

    ngrok_token=$(whiptail --inputbox "NGROK Token (optional):" 8 60 "$ngrok_token" --title "NGROK Setup" 3>&1 1>&2 2>&3)
    [ $? -ne 0 ] && return

    ngrok_args=$(whiptail --inputbox "NGROK Args (e.g., --url yourdomain.ngrok.io):" 8 70 "$ngrok_args" --title "NGROK Setup" 3>&1 1>&2 2>&3)
    [ $? -ne 0 ] && return

    visual=$(whiptail --title "Default Editor" --menu "Choose your editor:" 12 50 3 \
        "vim" "" \
        "emacs" "" \
        "nano" "" 3>&1 1>&2 2>&3)
    [ $? -ne 0 ] && return

    # Strip .signalwire.com if included
    sw_space=$(echo "$sw_space" | sed 's/\.signalwire\.com//g')

    # Preserve existing extra variables from .env (like AI keys)
    # Match lines that don't start with the known variables (handles both quoted and unquoted)
    local existing_extra=""
    if [ -f /workdir/.env ]; then
        existing_extra=$(grep -v -E '^(SIGNALWIRE_SPACE_NAME|SIGNALWIRE_PROJECT_ID|SIGNALWIRE_TOKEN|FREESWITCH_PAT|NGROK_TOKEN|NGROK_ARGS|VISUAL|WORKDIR)=' /workdir/.env 2>/dev/null | grep -v '^#' | grep -v '^$' | grep -v '^[[:space:]]*$')
    fi

    # Write .env file (quote values to handle special characters)
    cat > /workdir/.env << ENVEOF
SIGNALWIRE_SPACE_NAME="$sw_space"
SIGNALWIRE_PROJECT_ID="$project_id"
SIGNALWIRE_TOKEN="$api_token"
FREESWITCH_PAT="$freeswitch_pat"
NGROK_TOKEN="$ngrok_token"
NGROK_ARGS="$ngrok_args"
VISUAL="$visual"
WORKDIR="/workdir"
ENVEOF

    # Append any existing extra variables
    if [ -n "$existing_extra" ]; then
        echo "" >> /workdir/.env
        echo "# Additional settings" >> /workdir/.env
        echo "$existing_extra" >> /workdir/.env
    fi

    # Export for current session
    export SIGNALWIRE_SPACE_NAME="$sw_space"
    export SIGNALWIRE_PROJECT_ID="$project_id"
    export SIGNALWIRE_TOKEN="$api_token"
    export FREESWITCH_PAT="$freeswitch_pat"
    export NGROK_TOKEN="$ngrok_token"
    export NGROK_ARGS="$ngrok_args"
    export VISUAL="$visual"
    export WORKDIR="/workdir"

    # Show loading while preparing to test
    loading_screen "Saving" "Saving credentials..." 1

    # Test credentials with progress
    local response_code
    (
        echo 50
        response_code=$(curl -s -o /dev/null -w "%{http_code}" "https://${sw_space}.signalwire.com/api/laml/2010-04-01/Accounts" -u "${project_id}:${api_token}")
        echo "$response_code" > /tmp/sw_test.txt
        echo 100
    ) | whiptail --title "Testing Credentials" --gauge "Validating SignalWire API..." 8 50 0

    response_code=$(cat /tmp/sw_test.txt 2>/dev/null)
    rm -f /tmp/sw_test.txt

    local status_msg=""
    if [ "$response_code" = "200" ]; then
        status_msg="[OK] SignalWire API test successful!"
    else
        status_msg="[!!] SignalWire API test failed (HTTP $response_code)"
    fi

    # Check if ngrok is running
    local ngrok_running=false
    if curl -s http://127.0.0.1:4040/api/tunnels > /dev/null 2>&1; then
        ngrok_running=true
    fi

    # If ngrok token was provided and ngrok isn't running, offer to start it
    if [ -n "$ngrok_token" ] && [ "$ngrok_running" = "false" ]; then
        if whiptail --title "Credentials Saved" --yesno "Credentials saved to /workdir/.env\n\n$status_msg\n\nngrok is not running. Start ngrok tunnel now?" 14 55; then
            start_ngrok
            if whiptail --title "Setup Complete" --yesno "Reload shell to apply all changes?" 8 50; then
                exec bash
            fi
        fi
    else
        whiptail --title "Credentials Saved" --msgbox "Credentials saved to /workdir/.env\n\n$status_msg" 10 50
    fi
}

setup_golang() {
    ARCH=$(uname -m | sed 's/aarch64/arm64/g' | sed 's/x86_64/amd64/g')

    if [ -d "/workdir/.go" ]; then
        whiptail --title "Go Already Installed" --yesno "Go is already installed. Reinstall?" 8 50
        [ $? -ne 0 ] && return
        rm -rf /workdir/.go
    fi

    (
        echo 10
        echo "XXX"
        echo "Fetching latest Go version..."
        echo "XXX"
        GO_VERSION=$(curl -s https://go.dev/VERSION?m=text | head -1)
        echo "$GO_VERSION" > /tmp/go_version.txt

        echo 30
        echo "XXX"
        echo "Downloading ${GO_VERSION}..."
        echo "XXX"
        cd /tmp
        wget -q "https://go.dev/dl/${GO_VERSION}.linux-${ARCH}.tar.gz"

        echo 70
        echo "XXX"
        echo "Extracting..."
        echo "XXX"
        mkdir -p /workdir/.go
        tar -zxf "${GO_VERSION}.linux-${ARCH}.tar.gz" -C /workdir/.go --strip-components=1
        rm -f "${GO_VERSION}.linux-${ARCH}.tar.gz"

        echo 100
    ) | whiptail --title "Installing Go" --gauge "Preparing..." 8 60 0

    GO_VERSION=$(cat /tmp/go_version.txt 2>/dev/null)
    rm -f /tmp/go_version.txt
    whiptail --title "Go Installed" --msgbox "Go ${GO_VERSION} installed to /workdir/.go\n\nRun 'exec bash' to update PATH." 10 50
}

setup_nvm() {
    if [ -d "/workdir/.nvm" ]; then
        whiptail --title "NVM Already Installed" --yesno "NVM is already installed. Reinstall?" 8 50
        [ $? -ne 0 ] && return
        rm -rf /workdir/.nvm
    fi

    (
        echo 10
        echo "XXX"
        echo "Downloading NVM..."
        echo "XXX"
        mkdir -p /workdir/.nvm
        export NVM_DIR="/workdir/.nvm"
        curl -s -o- https://raw.githubusercontent.com/nvm-sh/nvm/master/install.sh | bash > /dev/null 2>&1

        echo 50
        echo "XXX"
        echo "Installing Node.js LTS..."
        echo "XXX"
        source /workdir/.nvm/nvm.sh
        nvm install --lts > /dev/null 2>&1

        echo 100
    ) | whiptail --title "Installing NVM + Node.js" --gauge "Preparing..." 8 60 0

    whiptail --title "NVM Installed" --msgbox "NVM installed to /workdir/.nvm\nNode LTS installed.\n\nRun 'exec bash' to update PATH." 10 50
}

setup_pgsql() {
    PG_VERSION="15"
    NEW_PGDATA="/workdir/postgres"

    if [ -d "$NEW_PGDATA" ] && [ -f "/workdir/.setuppgsql" ]; then
        whiptail --title "PostgreSQL Already Setup" --yesno "PostgreSQL data directory exists. Reinitialize?\n\nWARNING: This will delete existing data!" 10 50
        [ $? -ne 0 ] && return
        sudo /etc/init.d/postgresql stop 2>/dev/null
        rm -rf "$NEW_PGDATA"
        rm -f /workdir/.setuppgsql
    fi

    (
        echo 10
        echo "XXX"
        echo "Stopping existing PostgreSQL..."
        echo "XXX"
        sudo /etc/init.d/postgresql stop 2>/dev/null

        echo 30
        echo "XXX"
        echo "Creating data directory..."
        echo "XXX"
        mkdir -p "$NEW_PGDATA"
        sudo chown postgres:postgres "$NEW_PGDATA"
        sudo chmod 700 "$NEW_PGDATA"

        echo 50
        echo "XXX"
        echo "Initializing database cluster..."
        echo "XXX"
        sudo -u postgres /usr/lib/postgresql/${PG_VERSION}/bin/initdb -D "$NEW_PGDATA" > /dev/null 2>&1

        echo 80
        echo "XXX"
        echo "Starting PostgreSQL..."
        echo "XXX"
        sudo -u postgres /usr/lib/postgresql/${PG_VERSION}/bin/pg_ctl -D "$NEW_PGDATA" -l /workdir/postgres/logfile start > /dev/null 2>&1
        touch /workdir/.setuppgsql

        echo 100
    ) | whiptail --title "Setting up PostgreSQL" --gauge "Preparing..." 8 60 0

    whiptail --title "PostgreSQL Setup" --msgbox "PostgreSQL initialized in /workdir/postgres\n\nService is running." 10 50
}

setup_npm() {
    mkdir -p /workdir/.npm
    npm config set cache /workdir/.npm 2>/dev/null
    whiptail --title "NPM Cache" --msgbox "NPM cache set to /workdir/.npm" 8 50
}

setup_python_dev() {
    whiptail --title "Python Dev Tools" --yesno "Install Python development packages?\n\n- pdb++ (better debugger)\n- icecream (debug printing)\n- rich (beautiful output)\n- pytest + pytest-asyncio\n- uvicorn (ASGI server)\n- websockets, pydantic, loguru" 16 55
    [ $? -ne 0 ] && return

    (
        echo 0
        pip3 install --break-system-packages \
            pdbpp icecream rich \
            pytest pytest-asyncio \
            uvicorn gunicorn \
            websockets websocket-client \
            pydantic pyyaml \
            loguru structlog \
            aiohttp httpx > /dev/null 2>&1 &
        pid=$!

        while kill -0 $pid 2>/dev/null; do
            echo $((RANDOM % 40 + 30))
            sleep 1
        done
        wait $pid
        echo 100
    ) | whiptail --title "Installing Python Dev Tools" --gauge "Installing packages..." 8 60 0

    whiptail --title "Python Dev Tools" --msgbox "Python development packages installed!" 8 50
}

setup_audio_tools() {
    whiptail --title "Audio Tools" --yesno "Install audio/media tools?\n\n- ffmpeg (audio/video processing)\n- sox (sound processing)\n- pydub (Python audio)" 12 55
    [ $? -ne 0 ] && return

    (
        echo 20
        echo "XXX"
        echo "Installing ffmpeg and sox..."
        echo "XXX"
        apt-get update > /dev/null 2>&1
        apt-get install -y ffmpeg sox > /dev/null 2>&1

        echo 70
        echo "XXX"
        echo "Installing Python audio packages..."
        echo "XXX"
        pip3 install --break-system-packages pydub soundfile > /dev/null 2>&1

        echo 100
    ) | whiptail --title "Installing Audio Tools" --gauge "Preparing..." 8 60 0

    whiptail --title "Audio Tools" --msgbox "Audio tools installed!\n\nffmpeg, sox, pydub ready to use." 10 50
}

setup_ssh_key() {
    if [ -f "/workdir/.ssh/id_ed25519" ]; then
        whiptail --title "SSH Key Exists" --yesno "SSH key already exists.\n\nRegenerate? (This will overwrite!)" 10 55
        [ $? -ne 0 ] && return
    fi

    local email=$(whiptail --inputbox "Email for SSH key:" 8 60 "" --title "SSH Key Setup" 3>&1 1>&2 2>&3)
    [ $? -ne 0 ] && return

    mkdir -p /workdir/.ssh
    chmod 700 /workdir/.ssh
    ssh-keygen -t ed25519 -C "$email" -f /workdir/.ssh/id_ed25519 -N "" > /dev/null 2>&1

    rm -rf ~/.ssh
    ln -s /workdir/.ssh ~/.ssh

    local pubkey=$(cat /workdir/.ssh/id_ed25519.pub)
    whiptail --title "SSH Key Generated" --msgbox "SSH key generated!\n\nPublic key:\n${pubkey}\n\nAdd this to GitHub/GitLab." 16 70
}

setup_git_identity() {
    local current_name=$(git config --global user.name 2>/dev/null)
    local current_email=$(git config --global user.email 2>/dev/null)
    local current_token="${GITHUB_TOKEN:-}"

    local name=$(whiptail --inputbox "Git user name:" 8 60 "$current_name" --title "Git Identity" 3>&1 1>&2 2>&3)
    [ $? -ne 0 ] && return

    local email=$(whiptail --inputbox "Git email:" 8 60 "$current_email" --title "Git Identity" 3>&1 1>&2 2>&3)
    [ $? -ne 0 ] && return

    local github_token=$(whiptail --inputbox "GitHub Personal Access Token (optional):\n\nUsed for: gh CLI, MCP github server, private repos" 10 70 "$current_token" --title "GitHub Token" 3>&1 1>&2 2>&3)
    [ $? -ne 0 ] && return

    cat > /workdir/.gitconfig << GITEOF
[user]
    name = $name
    email = $email
[init]
    defaultBranch = main
[core]
    editor = ${VISUAL:-vim}
[pull]
    rebase = false
GITEOF

    ln -sf /workdir/.gitconfig ~/.gitconfig

    # Save GitHub token to .env if provided
    if [ -n "$github_token" ]; then
        if [ -f "/workdir/.env" ]; then
            sed -i '/^GITHUB_TOKEN=/d' /workdir/.env
        fi
        echo "GITHUB_TOKEN=$github_token" >> /workdir/.env
        export GITHUB_TOKEN="$github_token"
    fi

    local msg="Git configured!\n\nName: $name\nEmail: $email"
    if [ -n "$github_token" ]; then
        msg+="\nGitHub Token: Saved to .env"
    fi
    whiptail --title "Git Identity" --msgbox "$msg" 12 50
}

setup_ai_keys() {
    # Show loading while checking OAuth status
    loading_screen "AI Setup" "Checking authentication status..." 1

    # Check if logged in via OAuth
    local claude_oauth=false
    local gemini_oauth=false
    local oauth_msg=""

    # Check Claude OAuth - credentials file with claudeAiOauth key
    if [ -f "/workdir/.claude/.credentials.json" ] && grep -q "claudeAiOauth" /workdir/.claude/.credentials.json 2>/dev/null; then
        claude_oauth=true
        oauth_msg+="Claude Code: OAuth logged in\n"
    fi

    # Check Gemini OAuth
    if [ -f "/workdir/.gemini/oauth_creds.json" ]; then
        gemini_oauth=true
        oauth_msg+="Gemini CLI: OAuth logged in\n"
    fi

    # If both are OAuth, don't allow setting keys
    if [ "$claude_oauth" = true ] && [ "$gemini_oauth" = true ]; then
        whiptail --title "OAuth Active" --msgbox "Both tools are logged in via OAuth:\n\n${oauth_msg}\nAPI keys are not needed.\n\nTo use API keys instead:\n- Claude: run 'claude logout'\n- Gemini: remove /workdir/.gemini/oauth_creds.json" 16 60
        return
    fi

    # If one is OAuth, show which one and only prompt for the other
    if [ "$claude_oauth" = true ]; then
        whiptail --title "Claude OAuth Active" --msgbox "Claude Code is logged in via OAuth.\n\nOnly Gemini API key can be configured." 10 55
    fi
    if [ "$gemini_oauth" = true ]; then
        whiptail --title "Gemini OAuth Active" --msgbox "Gemini CLI is logged in via OAuth.\n\nOnly Claude API key can be configured." 10 55
    fi

    local anthropic_key="${ANTHROPIC_API_KEY:-}"
    local gemini_key="${GEMINI_API_KEY:-}"

    # Only prompt for keys if not using OAuth for that service
    if [ "$claude_oauth" = false ]; then
        anthropic_key=$(whiptail --inputbox "Anthropic API Key (for Claude Code):" 8 70 "$anthropic_key" --title "AI API Keys" 3>&1 1>&2 2>&3)
        [ $? -ne 0 ] && return
    fi

    if [ "$gemini_oauth" = false ]; then
        gemini_key=$(whiptail --inputbox "Google Gemini API Key:" 8 70 "$gemini_key" --title "AI API Keys" 3>&1 1>&2 2>&3)
        [ $? -ne 0 ] && return
    fi

    # Save non-OAuth keys to .env
    if [ -f "/workdir/.env" ]; then
        sed -i '/^ANTHROPIC_API_KEY=/d' /workdir/.env
        sed -i '/^GEMINI_API_KEY=/d' /workdir/.env
    fi

    if [ "$claude_oauth" = false ] && [ -n "$anthropic_key" ]; then
        echo "ANTHROPIC_API_KEY=$anthropic_key" >> /workdir/.env
        export ANTHROPIC_API_KEY="$anthropic_key"
    fi

    if [ "$gemini_oauth" = false ] && [ -n "$gemini_key" ]; then
        echo "GEMINI_API_KEY=$gemini_key" >> /workdir/.env
        export GEMINI_API_KEY="$gemini_key"
    fi

    whiptail --title "AI API Keys" --msgbox "API keys saved to /workdir/.env" 8 50
}

setup_mcp() {
    # Check if NVM/Node is installed
    if [ ! -d "/workdir/.nvm" ]; then
        if whiptail --title "Node.js Required" --yesno "MCP servers require Node.js.\n\nInstall NVM + Node.js now?" 10 50; then
            setup_nvm
        else
            return
        fi
    fi

    # Source NVM
    export NVM_DIR="/workdir/.nvm"
    [ -s "$NVM_DIR/nvm.sh" ] && source "$NVM_DIR/nvm.sh"

    # Check what's available
    local has_claude=$(command -v claude >/dev/null 2>&1 && echo "yes" || echo "no")
    local has_gemini=$(command -v gemini >/dev/null 2>&1 && echo "yes" || echo "no")

    if [ "$has_claude" = "no" ] && [ "$has_gemini" = "no" ]; then
        whiptail --title "No AI CLI Found" --msgbox "Neither Claude Code nor Gemini CLI is installed.\n\nInstall one of them first:\n- claude: npm install -g @anthropic-ai/claude-code\n- gemini: npm install -g @anthropic-ai/gemini-cli" 12 60
        return
    fi

    local tools_msg=""
    [ "$has_claude" = "yes" ] && tools_msg+="- Claude Code\n"
    [ "$has_gemini" = "yes" ] && tools_msg+="- Gemini CLI\n"

    whiptail --title "MCP Servers" --msgbox "This will configure MCP servers for:\n\n${tools_msg}\nServers to be added:\n- filesystem (file operations)\n- memory (persistent notes)\n- postgres (if PostgreSQL configured)\n- github (if GITHUB_TOKEN set)" 16 60

    # Install MCP servers using CLI commands
    clear
    echo "========================================"
    echo "Installing MCP Servers"
    echo "========================================"
    echo ""

    # Helper function to add server to both CLIs
    # Usage: add_mcp_server "name" [--env KEY=VALUE ...] -- command args...
    add_mcp_server() {
        local name="$1"
        shift

        # Parse --env arguments
        local claude_env_args=""
        local gemini_env_prefix=""
        while [ "$1" != "--" ] && [ $# -gt 0 ]; do
            if [ "$1" = "--env" ]; then
                shift
                claude_env_args+="--env $1 "
                gemini_env_prefix+="$1 "
                shift
            else
                shift
            fi
        done
        # Skip the "--" separator
        [ "$1" = "--" ] && shift

        echo "Adding $name..."

        if [ "$has_claude" = "yes" ]; then
            echo "  -> Claude Code"
            eval "claude mcp add --scope user \"$name\" $claude_env_args-- \"\$@\"" 2>/dev/null || true
        fi

        if [ "$has_gemini" = "yes" ]; then
            echo "  -> Gemini CLI"
            eval "$gemini_env_prefix gemini mcp add \"$name\" -- \"\$@\"" 2>/dev/null || true
        fi
        echo ""
    }

    # filesystem - file operations on /workdir
    add_mcp_server "filesystem" -- npx -y @modelcontextprotocol/server-filesystem /workdir

    # memory - persistent notes
    add_mcp_server "memory" -- npx -y @modelcontextprotocol/server-memory

    # postgres - only if configured (requires connection URL as argument)
    if [ -f "/workdir/.setuppgsql" ]; then
        add_mcp_server "postgres" -- npx -y @modelcontextprotocol/server-postgres postgresql://postgres@localhost/postgres
    fi

    # github - only if token set
    if [ -n "$GITHUB_TOKEN" ]; then
        add_mcp_server "github" --env GITHUB_TOKEN="$GITHUB_TOKEN" -- npx -y @modelcontextprotocol/server-github
    fi

    echo "========================================"
    echo "MCP Servers Installed!"
    echo "========================================"
    echo ""

    if [ "$has_claude" = "yes" ]; then
        echo "Claude Code servers:"
        claude mcp list 2>/dev/null || echo "  (run 'claude mcp list' to verify)"
        echo ""
    fi

    if [ "$has_gemini" = "yes" ]; then
        echo "Gemini CLI servers:"
        gemini mcp list 2>/dev/null || echo "  (run 'gemini mcp list' to verify)"
        echo ""
    fi

    read -p "Press Enter to continue..."
}

remove_mcp() {
    # Check what's available
    local has_claude=$(command -v claude >/dev/null 2>&1 && echo "yes" || echo "no")
    local has_gemini=$(command -v gemini >/dev/null 2>&1 && echo "yes" || echo "no")

    if [ "$has_claude" = "no" ] && [ "$has_gemini" = "no" ]; then
        whiptail --title "No AI CLI Found" --msgbox "Neither Claude Code nor Gemini CLI is installed." 8 50
        return
    fi

    # Get list of servers
    local servers=""
    if [ "$has_claude" = "yes" ]; then
        servers=$(claude mcp list 2>/dev/null | grep -E "^\s+\w+" | awk '{print $1}' | sort -u)
    fi
    if [ "$has_gemini" = "yes" ]; then
        local gemini_servers=$(gemini mcp list 2>/dev/null | grep -E "^\s+\w+" | awk '{print $1}' | sort -u)
        servers=$(echo -e "$servers\n$gemini_servers" | sort -u | grep -v '^$')
    fi

    if [ -z "$servers" ]; then
        whiptail --title "No MCP Servers" --msgbox "No MCP servers are currently configured." 8 50
        return
    fi

    # Build menu options
    local menu_items=""
    local count=1
    for server in $servers; do
        menu_items+="\"$count\" \"$server\" "
        count=$((count + 1))
    done

    local choice=$(eval "whiptail --title \"Remove MCP Server\" --menu \"Select server to remove:\" 20 50 10 $menu_items" 3>&1 1>&2 2>&3)
    [ $? -ne 0 ] && return

    # Get server name from choice
    local server_name=$(echo "$servers" | sed -n "${choice}p")

    if whiptail --title "Confirm Removal" --yesno "Remove MCP server '$server_name' from all tools?" 8 50; then
        clear
        echo "Removing $server_name..."

        if [ "$has_claude" = "yes" ]; then
            echo "  -> Claude Code"
            claude mcp remove "$server_name" 2>/dev/null || true
        fi

        if [ "$has_gemini" = "yes" ]; then
            echo "  -> Gemini CLI"
            gemini mcp remove "$server_name" 2>/dev/null || true
        fi

        echo ""
        echo "Done!"
        read -p "Press Enter to continue..."
    fi
}

setup_freeswitch() {
    # Show loading while checking tokens
    loading_screen "FreeSWITCH" "Checking available tokens..." 1

    # Determine which token to use - SIGNALWIRE_TOKEN first (Enterprise), then FREESWITCH_PAT (OSS)
    local token=""
    local token_type=""

    if [ -n "$SIGNALWIRE_TOKEN" ]; then
        token="$SIGNALWIRE_TOKEN"
        token_type="SIGNALWIRE_TOKEN (Enterprise if scope enabled)"
    elif [ -n "$FREESWITCH_PAT" ]; then
        token="$FREESWITCH_PAT"
        token_type="FREESWITCH_PAT (Community)"
    else
        whiptail --title "No Token Available" --msgbox "No FreeSWITCH token found.\n\nConfigure one of:\n- SIGNALWIRE_TOKEN (for Enterprise, requires FreeSWITCH Access scope)\n- FREESWITCH_PAT (for Community/OSS)\n\nUse option 1 to set up credentials." 14 65
        return 1
    fi

    # Show which token will be used
    whiptail --title "FreeSWITCH Installation" --yesno "Token detected: $token_type\n\nThe installer will automatically detect:\n- PT* tokens → FreeSWITCH Enterprise\n- pat_* tokens → FreeSWITCH Community\n\nContinue with installation?" 14 65
    [ $? -ne 0 ] && return

    # Choose release channel
    local channel=$(whiptail --title "FreeSWITCH Channel" --menu "Select release channel:" 12 50 2 \
        "release" "Stable release (recommended)" \
        "prerelease" "Pre-release / testing" \
        3>&1 1>&2 2>&3)
    [ $? -ne 0 ] && return

    # Run the installer with visible output
    clear
    echo "========================================"
    echo "Installing FreeSWITCH ($channel)"
    echo "========================================"
    echo ""

    curl -sSL https://freeswitch.org/fsget | bash -s "$token" "$channel" install
    local status=$?

    echo ""
    echo "========================================"
    if [ $status -eq 0 ]; then
        echo "Installation completed!"
    else
        echo "Installation finished with exit code: $status"
    fi
    echo "========================================"
    echo ""
    read -p "Press Enter to continue..."
}

toggle_swsh() {
    if [ -f "/workdir/.noswsh" ]; then
        # Currently disabled, offer to enable
        if whiptail --title "SignalWire Shell" --yesno "swsh is currently DISABLED on login.\n\nEnable swsh to start automatically?" 10 55; then
            rm -f /workdir/.noswsh
            whiptail --title "swsh Enabled" --msgbox "swsh will now start on login.\n\nRun 'exec bash' to test." 10 50
        fi
    else
        # Currently enabled, offer to disable
        if whiptail --title "SignalWire Shell" --yesno "swsh is currently ENABLED on login.\n\nDisable swsh auto-start?\n\n(You can still run 'swsh' manually)" 12 55; then
            touch /workdir/.noswsh
            whiptail --title "swsh Disabled" --msgbox "swsh will no longer start on login.\n\nRun 'swsh' manually when needed." 10 50
        fi
    fi
}

clean_environment() {
    CLEAN_CHOICE=$(whiptail --title "Clean Environment" --menu "What do you want to clean?" 16 60 6 \
        "1" "Clean all Python venvs" \
        "2" "Clean NPM cache" \
        "3" "Clean pip cache" \
        "4" "Clean all caches" \
        "5" "Clean AI configs (Claude/Gemini)" \
        "6" "Full reset (remove all dev tools + AI)" \
        3>&1 1>&2 2>&3)

    [ $? -ne 0 ] && return

    case $CLEAN_CHOICE in
        "1")
            if whiptail --title "Confirm" --yesno "Delete ALL Python virtual environments?" 8 50; then
                rm -rf /workdir/.venvs
                mkdir -p /workdir/.venvs
                whiptail --title "Cleaned" --msgbox "All venvs deleted." 8 40
            fi
            ;;
        "2")
            rm -rf /workdir/.npm/*
            whiptail --title "Cleaned" --msgbox "NPM cache cleared." 8 40
            ;;
        "3")
            pip3 cache purge 2>/dev/null
            whiptail --title "Cleaned" --msgbox "Pip cache cleared." 8 40
            ;;
        "4")
            rm -rf /workdir/.npm/*
            pip3 cache purge 2>/dev/null
            whiptail --title "Cleaned" --msgbox "All caches cleared." 8 40
            ;;
        "5")
            if whiptail --title "Confirm" --yesno "This will remove:\n\n- Claude Code config (.claude/)\n- Gemini CLI config (.gemini/)\n- AI API keys from .env\n\nYou will need to re-login or re-enter API keys." 14 55; then
                rm -rf /workdir/.claude /workdir/.gemini
                if [ -f "/workdir/.env" ]; then
                    sed -i '/^ANTHROPIC_API_KEY=/d' /workdir/.env
                    sed -i '/^GEMINI_API_KEY=/d' /workdir/.env
                fi
                unset ANTHROPIC_API_KEY GEMINI_API_KEY
                whiptail --title "Cleaned" --msgbox "AI configs removed.\n\nRun 'claude login' or setup AI keys." 10 50
            fi
            ;;
        "6")
            if whiptail --title "DANGER" --yesno "This will remove:\n\n- All venvs\n- Go installation\n- NVM + Node\n- PostgreSQL data\n- All caches\n- Claude/Gemini configs\n- AI API keys\n\nCredentials and SSH keys kept.\n\nAre you SURE?" 20 50; then
                rm -rf /workdir/.venvs /workdir/.go /workdir/.nvm /workdir/.npm /workdir/postgres
                rm -rf /workdir/.claude /workdir/.gemini
                rm -f /workdir/.setuppgsql
                if [ -f "/workdir/.env" ]; then
                    sed -i '/^ANTHROPIC_API_KEY=/d' /workdir/.env
                    sed -i '/^GEMINI_API_KEY=/d' /workdir/.env
                fi
                pip3 cache purge 2>/dev/null
                unset ANTHROPIC_API_KEY GEMINI_API_KEY
                whiptail --title "Reset Complete" --msgbox "Environment reset.\n\nRun 'exec bash' then 'setup' to reinstall." 10 50
            fi
            ;;
    esac
}

setup_all() {
    whiptail --title "Setup All" --yesno "This will setup:\n\n- Go (latest)\n- NVM + Node LTS\n- PostgreSQL\n- NPM cache\n- Python dev tools\n\nContinue?" 16 50
    [ $? -ne 0 ] && return

    setup_golang
    setup_nvm
    setup_pgsql
    setup_npm
    setup_python_dev

    whiptail --title "Setup Complete" --msgbox "All development tools installed!\n\nRun 'exec bash' to update environment." 10 50
}

show_status() {
    # Gather status in background while showing spinner
    gather_status() {
        local STATUS="=== Services ===\n"

        # Redis status
        if pgrep -x redis-server > /dev/null 2>&1; then
            STATUS+="Redis: [OK] Running\n"
        else
            STATUS+="Redis: [--] Not running\n"
        fi

        # nginx status
        if pgrep -x nginx > /dev/null 2>&1; then
            STATUS+="nginx: [OK] Running\n"
        else
            STATUS+="nginx: [--] Not running\n"
        fi

        # ngrok status
        if [ -n "$NGROK_TOKEN" ]; then
            local ngrok_url=$(curl -s http://127.0.0.1:4040/api/tunnels 2>/dev/null | jq -r '.tunnels[0].public_url' 2>/dev/null)
            if [ -n "$ngrok_url" ] && [ "$ngrok_url" != "null" ]; then
                STATUS+="ngrok: [OK] $ngrok_url\n"
            else
                STATUS+="ngrok: [!!] Token set but not running\n"
            fi
        else
            STATUS+="ngrok: [--] Not configured\n"
        fi

        # Docker socket
        if [ -S /var/run/docker.sock ]; then
            STATUS+="Docker: [OK] Socket available\n"
        else
            STATUS+="Docker: [--] No socket\n"
        fi

        STATUS+="\n=== Credentials ===\n"

        if [ -n "$SIGNALWIRE_SPACE_NAME" ] && [ -n "$SIGNALWIRE_PROJECT_ID" ] && [ -n "$SIGNALWIRE_TOKEN" ]; then
            STATUS+="SignalWire: [OK] ${SIGNALWIRE_SPACE_NAME}\n"
        else
            STATUS+="SignalWire: [--] Not configured\n"
        fi

        # Check Claude Code auth - OAuth credentials file or API key
        if [ -f "/workdir/.claude/.credentials.json" ] && grep -q "claudeAiOauth" /workdir/.claude/.credentials.json 2>/dev/null; then
            STATUS+="Claude Code: [OK] OAuth logged in\n"
        elif [ -n "$ANTHROPIC_API_KEY" ]; then
            STATUS+="Claude Code: [OK] API key configured\n"
        else
            STATUS+="Claude Code: [--] Not configured\n"
        fi

        # Check Gemini CLI auth - OAuth file or API key
        if [ -f "/workdir/.gemini/oauth_creds.json" ]; then
            STATUS+="Gemini CLI: [OK] OAuth logged in\n"
        elif [ -n "$GEMINI_API_KEY" ]; then
            STATUS+="Gemini CLI: [OK] API key configured\n"
        else
            STATUS+="Gemini CLI: [--] Not configured\n"
        fi

        if [ -f "/workdir/.ssh/id_ed25519" ]; then
            STATUS+="SSH Key: [OK] Configured\n"
        else
            STATUS+="SSH Key: [--] Not configured\n"
        fi

        if [ -f "/workdir/.gitconfig" ]; then
            local git_name=$(git config --global user.name 2>/dev/null)
            STATUS+="Git Identity: [OK] ${git_name}\n"
        else
            STATUS+="Git Identity: [--] Not configured\n"
        fi

        STATUS+="\n=== Dev Tools ===\n"

        # Python version
        local py_ver=$(python3 --version 2>/dev/null | awk '{print $2}')
        STATUS+="Python: [OK] ${py_ver}\n"

        # Active venv
        if [ -n "$VIRTUAL_ENV" ]; then
            STATUS+="Active venv: [OK] $(basename $VIRTUAL_ENV)\n"
        else
            STATUS+="Active venv: [--] None\n"
        fi

        # Venv count
        if [ -d "/workdir/.venvs" ]; then
            local VENV_COUNT=$(ls -1 /workdir/.venvs/ 2>/dev/null | wc -l | tr -d ' ')
            STATUS+="Python venvs: [OK] ${VENV_COUNT} saved\n"
        else
            STATUS+="Python venvs: [--] None\n"
        fi

        if [ -d "/workdir/.go" ]; then
            local GO_VER=$(/workdir/.go/bin/go version 2>/dev/null | awk '{print $3}')
            STATUS+="Go: [OK] ${GO_VER}\n"
        else
            STATUS+="Go: [--] Not installed\n"
        fi

        if [ -d "/workdir/.nvm" ]; then
            # Try to get node version
            local node_ver=""
            if [ -f "/workdir/.nvm/nvm.sh" ]; then
                node_ver=$(source /workdir/.nvm/nvm.sh 2>/dev/null && node --version 2>/dev/null)
            fi
            if [ -n "$node_ver" ]; then
                STATUS+="Node.js: [OK] ${node_ver}\n"
            else
                STATUS+="NVM: [OK] Installed\n"
            fi
        else
            STATUS+="NVM: [--] Not installed\n"
        fi

        if [ -f "/workdir/.setuppgsql" ]; then
            if pgrep -x postgres > /dev/null 2>&1; then
                STATUS+="PostgreSQL: [OK] Running\n"
            else
                STATUS+="PostgreSQL: [!!] Configured but not running\n"
            fi
        else
            STATUS+="PostgreSQL: [--] Not configured\n"
        fi

        if command -v ffmpeg &>/dev/null; then
            STATUS+="Audio Tools: [OK] Installed\n"
        else
            STATUS+="Audio Tools: [--] Not installed\n"
        fi

        # MCP servers
        local mcp_count=0
        if command -v claude >/dev/null 2>&1; then
            mcp_count=$(claude mcp list 2>/dev/null | grep -c "^\s" || echo "0")
        fi
        if [ "$mcp_count" -gt 0 ]; then
            STATUS+="MCP Servers: [OK] ${mcp_count} configured\n"
        else
            STATUS+="MCP Servers: [--] Not configured\n"
        fi

        # Container uptime
        local uptime=$(cat /proc/uptime 2>/dev/null | awk '{printf "%dd %dh %dm", $1/86400, ($1%86400)/3600, ($1%3600)/60}')
        STATUS+="\nUptime: ${uptime}\n"

        echo "$STATUS"
    }

    # Run gather_status in background and show spinner
    gather_status > /tmp/status_output.txt &
    local pid=$!

    local spinner='|/-\'
    local i=0
    while kill -0 $pid 2>/dev/null; do
        local spin_char="${spinner:i%4:1}"
        whiptail --title "Status" --infobox "Gathering system information... $spin_char" 7 50
        sleep 0.2
        i=$((i+1))
    done
    wait $pid

    # Display the gathered status
    local STATUS=$(cat /tmp/status_output.txt)
    rm -f /tmp/status_output.txt

    whiptail --title "Environment Status" --msgbox "$STATUS" 38 60
}

# Main menu loop - Cancel button exits
while true; do
    # Check ngrok status for menu
    ngrok_status="Start ngrok Tunnel"
    if curl -s http://127.0.0.1:4040/api/tunnels > /dev/null 2>&1; then
        ngrok_status="ngrok Running (restart)"
    fi

    # Check swsh status for menu
    swsh_status="Disable swsh on Login"
    if [ -f "/workdir/.noswsh" ]; then
        swsh_status="Enable swsh on Login"
    fi

    CHOICE=$(whiptail --title "WireStarter Environment Setup" --menu "Select an option (Cancel to exit):" 28 60 19 \
        "1" "Setup SignalWire & NGROK Credentials" \
        "2" "$ngrok_status" \
        "3" "Setup AI API Keys (Claude/Gemini)" \
        "4" "Add MCP Servers (Claude/Gemini)" \
        "5" "Remove MCP Server" \
        "6" "Setup Git Identity" \
        "7" "Setup SSH Key" \
        "8" "Setup Go (latest stable)" \
        "9" "Setup NVM + Node.js" \
        "10" "Setup PostgreSQL" \
        "11" "Setup FreeSWITCH" \
        "12" "Setup Python Dev Tools" \
        "13" "Setup Audio Tools (ffmpeg/sox)" \
        "14" "Setup All Dev Tools" \
        "15" "$swsh_status" \
        "16" "Show Status" \
        "17" "Clean Environment" \
        3>&1 1>&2 2>&3)

    # Cancel button or ESC exits
    [ $? -ne 0 ] && exit 0

    case $CHOICE in
        "1") setup_credentials ;;
        "2") start_ngrok ;;
        "3") setup_ai_keys ;;
        "4") setup_mcp ;;
        "5") remove_mcp ;;
        "6") setup_git_identity ;;
        "7") setup_ssh_key ;;
        "8") setup_golang ;;
        "9") setup_nvm ;;
        "10") setup_pgsql ;;
        "11") setup_freeswitch ;;
        "12") setup_python_dev ;;
        "13") setup_audio_tools ;;
        "14") setup_all ;;
        "15") toggle_swsh ;;
        "16") show_status ;;
        "17") clean_environment ;;
    esac
done
