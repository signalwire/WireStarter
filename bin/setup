#!/bin/bash
# WireStarter Environment Setup

# Set TERM if not set (needed for whiptail)
export TERM="${TERM:-xterm}"

# Persistent storage directory
PERSIST="/workdir/persistent"

# Load existing .env if present
if [ -f "$PERSIST/.env" ]; then
    set -a
    . $PERSIST/.env 2>/dev/null || true
    set +a
fi

# Show loading screen with spinner while running a command
# Usage: show_loading "Title" "Message" command args...
show_loading() {
    local title="$1"
    local message="$2"
    shift 2

    # Start the command in background
    "$@" &
    local pid=$!

    # Show spinner using whiptail infobox in a loop
    local spinner='|/-\'
    local i=0
    while kill -0 $pid 2>/dev/null; do
        local spin_char="${spinner:i%4:1}"
        whiptail --title "$title" --infobox "$message $spin_char" 7 50
        sleep 0.2
        i=$((i+1))
    done

    wait $pid
    return $?
}

# Quick loading screen (just shows message, no command)
# Usage: loading_screen "Title" "Message" seconds
loading_screen() {
    local title="$1"
    local message="$2"
    local duration="${3:-1}"

    local spinner='|/-\'
    local i=0
    local end=$((SECONDS + duration))
    while [ $SECONDS -lt $end ]; do
        local spin_char="${spinner:i%4:1}"
        whiptail --title "$title" --infobox "$message $spin_char" 7 50
        sleep 0.2
        i=$((i+1))
    done
}

# Run command with whiptail progress gauge
run_with_progress() {
    local title="$1"
    local message="$2"
    shift 2

    # Run command in background and show gauge
    (
        echo 10
        "$@" > /tmp/setup_output.log 2>&1
        echo 100
    ) | whiptail --title "$title" --gauge "$message" 8 60 0

    return ${PIPESTATUS[0]}
}

# Start ngrok tunnel (matches start_services.sh)
start_ngrok() {
    if [ -z "$NGROK_TOKEN" ]; then
        whiptail --title "ngrok" --msgbox "NGROK_TOKEN not set.\n\nPlease run 'Setup SignalWire & NGROK Credentials' first." 10 55
        return 1
    fi

    # Check if ngrok is already running
    if curl -s http://127.0.0.1:4040/api/tunnels > /dev/null 2>&1; then
        local existing_url=$(curl -s http://127.0.0.1:4040/api/tunnels | jq -r '.tunnels[0].public_url')
        whiptail --title "ngrok" --msgbox "ngrok is already running!\n\nTunnel: $existing_url" 10 60
        export NGROK_URL="$existing_url"
        return 0
    fi

    # Start ngrok with progress
    (
        echo 10
        echo "XXX"
        echo "Configuring ngrok token..."
        echo "XXX"
        /usr/local/bin/ngrok config add-authtoken "$NGROK_TOKEN" > /dev/null 2>&1

        echo 30
        echo "XXX"
        echo "Starting ngrok tunnel..."
        echo "XXX"
        /usr/bin/tmux new-session -d -s ngrok "/usr/local/bin/ngrok http $NGROK_ARGS 9080"

        # Wait for ngrok to be ready
        retry=0
        while [ $retry -lt 10 ]; do
            sleep 2
            url=$(curl -s http://127.0.0.1:4040/api/tunnels 2>/dev/null | jq -r '.tunnels[0].public_url' 2>/dev/null)
            if [ -n "$url" ] && [ "$url" != "null" ]; then
                echo "$url" > /tmp/ngrok_url.txt
                echo 100
                exit 0
            fi
            retry=$((retry + 1))
            progress=$((30 + retry * 7))
            echo $progress
            echo "XXX"
            echo "Waiting for tunnel... ($retry/10)"
            echo "XXX"
        done
        echo 100
        exit 1
    ) | whiptail --title "Starting ngrok" --gauge "Initializing..." 8 60 0

    # Check result
    if [ -f /tmp/ngrok_url.txt ]; then
        export NGROK_URL=$(cat /tmp/ngrok_url.txt)
        export HOSTNAME=$(echo "$NGROK_URL" | sed 's|https://||')
        rm -f /tmp/ngrok_url.txt
        whiptail --title "ngrok Started" --msgbox "Tunnel ready!\n\n$NGROK_URL" 10 60
        return 0
    else
        whiptail --title "ngrok Failed" --msgbox "Failed to start ngrok tunnel.\n\nCheck your token and try again." 10 50
        return 1
    fi
}

setup_cloudflare_tunnel() {
    # Check if cloudflared is installed
    if ! command -v cloudflared >/dev/null 2>&1; then
        whiptail --title "Cloudflare Tunnel" --msgbox "cloudflared is not installed.\n\nPlease rebuild the container with the latest image." 10 60
        return 1
    fi

    # Check if already configured
    if [ -f "$PERSIST/.cloudflared/token" ]; then
        if whiptail --title "Cloudflare Tunnel" --yesno "Cloudflare Tunnel is already configured.\n\nReconfigure?" 10 50; then
            # Kill existing tunnel
            tmux kill-session -t cloudflared 2>/dev/null || true
            rm -rf "$PERSIST/.cloudflared"
        else
            return 0
        fi
    fi

    # Get the tunnel token
    local cf_token
    cf_token=$(whiptail --inputbox "Enter your Cloudflare Tunnel Token:\n\n(From: Zero Trust > Networks > Tunnels > Create)" 12 70 "" --title "Cloudflare Tunnel Setup" 3>&1 1>&2 2>&3)
    [ $? -ne 0 ] && return
    [ -z "$cf_token" ] && return

    # Create config directory and save token
    mkdir -p "$PERSIST/.cloudflared"
    rm -rf ~/.cloudflared
    ln -sf "$PERSIST/.cloudflared" ~/.cloudflared

    # Save token to file (more secure than .env, permissions restricted)
    echo "$cf_token" > "$PERSIST/.cloudflared/token"
    chmod 600 "$PERSIST/.cloudflared/token"

    (
        echo 30
        echo "XXX"
        echo "Starting Cloudflare Tunnel..."
        echo "XXX"

        # Start tunnel in tmux session using env var to hide token from process list
        /usr/bin/tmux new-session -d -s cloudflared "TUNNEL_TOKEN=\$(cat $PERSIST/.cloudflared/token) exec cloudflared tunnel run"

        # Wait for tunnel to connect
        sleep 3
        echo 100
    ) | whiptail --title "Cloudflare Tunnel" --gauge "Configuring..." 8 60 0

    # Check if tmux session is running
    if tmux has-session -t cloudflared 2>/dev/null; then
        whiptail --title "Cloudflare Tunnel" --msgbox "Cloudflare Tunnel started successfully!\n\nThe tunnel is running in tmux session 'cloudflared'.\nAttach with: tmux attach -t cloudflared\n\nTraffic will be routed to port 9080.\n\nConfigure your tunnel hostname in the\nCloudflare Zero Trust dashboard." 16 58
    else
        whiptail --title "Cloudflare Tunnel Failed" --msgbox "Failed to start tunnel.\n\nCheck your token and try again.\nView logs: tmux attach -t cloudflared" 12 55
        return 1
    fi
}

setup_credentials() {
    # Reload .env to get latest values (in case file was modified externally)
    # Use a safer method that handles both quoted and unquoted values
    local sw_space="" project_id="" api_token="" freeswitch_pat="" ngrok_token="" ngrok_args="" visual="vim"
    if [ -f "$PERSIST/.env" ]; then
        # Parse each line manually to handle unquoted values with spaces
        while IFS= read -r line || [ -n "$line" ]; do
            # Skip comments and empty lines
            [[ "$line" =~ ^[[:space:]]*# ]] && continue
            [[ -z "$line" ]] && continue
            # Extract key and value, stripping quotes if present
            if [[ "$line" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*) ]]; then
                local key="${BASH_REMATCH[1]}"
                local val="${BASH_REMATCH[2]}"
                # Remove surrounding quotes if present
                val="${val#\"}" ; val="${val%\"}"
                val="${val#\'}" ; val="${val%\'}"
                case "$key" in
                    SIGNALWIRE_SPACE_NAME) sw_space="$val" ;;
                    SIGNALWIRE_PROJECT_ID) project_id="$val" ;;
                    SIGNALWIRE_TOKEN) api_token="$val" ;;
                    FREESWITCH_PAT) freeswitch_pat="$val" ;;
                    NGROK_TOKEN) ngrok_token="$val" ;;
                    NGROK_ARGS) ngrok_args="$val" ;;
                    VISUAL) visual="$val" ;;
                esac
            fi
        done < "$PERSIST/.env"
    fi

    # Fall back to environment if not found in file
    sw_space="${sw_space:-${SIGNALWIRE_SPACE_NAME:-}}"
    project_id="${project_id:-${SIGNALWIRE_PROJECT_ID:-}}"
    api_token="${api_token:-${SIGNALWIRE_TOKEN:-}}"
    freeswitch_pat="${freeswitch_pat:-${FREESWITCH_PAT:-}}"
    ngrok_token="${ngrok_token:-${NGROK_TOKEN:-}}"
    ngrok_args="${ngrok_args:-${NGROK_ARGS:-}}"
    visual="${visual:-vim}"

    # Required fields
    sw_space=$(whiptail --inputbox "SignalWire Space Name (required):" 8 60 "$sw_space" --title "SignalWire Credentials" 3>&1 1>&2 2>&3)
    [ $? -ne 0 ] && return

    project_id=$(whiptail --inputbox "Project ID (required):" 8 60 "$project_id" --title "SignalWire Credentials" 3>&1 1>&2 2>&3)
    [ $? -ne 0 ] && return

    api_token=$(whiptail --inputbox "SignalWire Token (required):" 8 60 "$api_token" --title "SignalWire Credentials" 3>&1 1>&2 2>&3)
    [ $? -ne 0 ] && return

    ngrok_token=$(whiptail --inputbox "NGROK Token (required):" 8 60 "$ngrok_token" --title "NGROK Setup" 3>&1 1>&2 2>&3)
    [ $? -ne 0 ] && return

    # Use -- to prevent whiptail from interpreting default value as options (e.g., --url)
    ngrok_args=$(whiptail --inputbox "NGROK Args (optional - e.g., --url yourdomain.ngrok.io):" 8 70 --title "Optional Settings" -- "$ngrok_args" 3>&1 1>&2 2>&3)
    [ $? -ne 0 ] && return

    # Optional fields
    freeswitch_pat=$(whiptail --inputbox "FreeSWITCH PAT (optional - for FreeSWITCH install):" 8 65 "$freeswitch_pat" --title "Optional Settings" 3>&1 1>&2 2>&3)
    [ $? -ne 0 ] && return

    visual=$(whiptail --title "Default Editor (optional)" --default-item "$visual" --menu "Choose your editor:" 14 50 5 \
        "vim" "Vi IMproved" \
        "emacs" "GNU Emacs" \
        "nano" "Simple editor" \
        "micro" "Modern terminal editor" \
        "ne" "Nice Editor" \
        3>&1 1>&2 2>&3)
    [ $? -ne 0 ] && return

    # Strip .signalwire.com if included
    sw_space=$(echo "$sw_space" | sed 's/\.signalwire\.com//g')

    # Preserve existing extra variables from .env (like AI keys)
    # Match lines that don't start with the known variables (handles both quoted and unquoted)
    local existing_extra=""
    if [ -f "$PERSIST/.env" ]; then
        existing_extra=$(grep -v -E '^(SIGNALWIRE_SPACE_NAME|SIGNALWIRE_PROJECT_ID|SIGNALWIRE_TOKEN|FREESWITCH_PAT|NGROK_TOKEN|NGROK_ARGS|VISUAL|WORKDIR)=' "$PERSIST/.env" 2>/dev/null | grep -v '^#' | grep -v '^$' | grep -v '^[[:space:]]*$')
    fi

    # Write .env file (quote values to handle special characters)
    mkdir -p "$PERSIST"
    cat > "$PERSIST/.env" << ENVEOF
SIGNALWIRE_SPACE_NAME="$sw_space"
SIGNALWIRE_PROJECT_ID="$project_id"
SIGNALWIRE_TOKEN="$api_token"
NGROK_TOKEN="$ngrok_token"
NGROK_ARGS="$ngrok_args"
FREESWITCH_PAT="$freeswitch_pat"
VISUAL="$visual"
WORKDIR="${WORKDIR:-/workdir}"
ENVEOF

    # Append any existing extra variables
    if [ -n "$existing_extra" ]; then
        echo "" >> "$PERSIST/.env"
        echo "# Additional settings" >> "$PERSIST/.env"
        echo "$existing_extra" >> "$PERSIST/.env"
    fi

    # Export for current session
    export SIGNALWIRE_SPACE_NAME="$sw_space"
    export SIGNALWIRE_PROJECT_ID="$project_id"
    export SIGNALWIRE_TOKEN="$api_token"
    export FREESWITCH_PAT="$freeswitch_pat"
    export NGROK_TOKEN="$ngrok_token"
    export NGROK_ARGS="$ngrok_args"
    export VISUAL="$visual"
    export WORKDIR="/workdir"

    # Show loading while preparing to test
    loading_screen "Saving" "Saving credentials..." 1

    # Test credentials with progress
    local response_code
    (
        echo 50
        response_code=$(curl -s -o /dev/null -w "%{http_code}" "https://${sw_space}.signalwire.com/api/laml/2010-04-01/Accounts" -u "${project_id}:${api_token}")
        echo "$response_code" > /tmp/sw_test.txt
        echo 100
    ) | whiptail --title "Testing Credentials" --gauge "Validating SignalWire API..." 8 50 0

    response_code=$(cat /tmp/sw_test.txt 2>/dev/null)
    rm -f /tmp/sw_test.txt

    local status_msg=""
    if [ "$response_code" = "200" ]; then
        status_msg="[OK] SignalWire API test successful!"
    else
        status_msg="[!!] SignalWire API test failed (HTTP $response_code)"
    fi

    # Check if ngrok is running
    local ngrok_running=false
    if curl -s http://127.0.0.1:4040/api/tunnels > /dev/null 2>&1; then
        ngrok_running=true
    fi

    # If ngrok token was provided and ngrok isn't running, offer to start it
    if [ -n "$ngrok_token" ] && [ "$ngrok_running" = "false" ]; then
        if whiptail --title "Credentials Saved" --yesno "Credentials saved to $PERSIST/.env\n\n$status_msg\n\nngrok is not running. Start ngrok tunnel now?" 14 55; then
            start_ngrok
            if whiptail --title "Setup Complete" --yesno "Reload shell to apply all changes?" 8 50; then
                exec bash
            fi
        fi
    else
        whiptail --title "Credentials Saved" --msgbox "Credentials saved to $PERSIST/.env\n\n$status_msg" 10 55
    fi
}

setup_golang() {
    ARCH=$(uname -m | sed 's/aarch64/arm64/g' | sed 's/x86_64/amd64/g')

    if [ -d "$PERSIST/.go" ]; then
        whiptail --title "Go Already Installed" --yesno "Go is already installed. Reinstall?" 8 50
        [ $? -ne 0 ] && return
        rm -rf "$PERSIST/.go"
    fi

    (
        echo 10
        echo "XXX"
        echo "Fetching latest Go version..."
        echo "XXX"
        GO_VERSION=$(curl -s https://go.dev/VERSION?m=text | head -1)
        echo "$GO_VERSION" > /tmp/go_version.txt

        echo 30
        echo "XXX"
        echo "Downloading ${GO_VERSION}..."
        echo "XXX"
        cd /tmp
        wget -q "https://go.dev/dl/${GO_VERSION}.linux-${ARCH}.tar.gz"

        echo 70
        echo "XXX"
        echo "Extracting..."
        echo "XXX"
        mkdir -p "$PERSIST/.go"
        tar -zxf "${GO_VERSION}.linux-${ARCH}.tar.gz" -C "$PERSIST/.go" --strip-components=1
        rm -f "${GO_VERSION}.linux-${ARCH}.tar.gz"

        echo 100
    ) | whiptail --title "Installing Go" --gauge "Preparing..." 8 60 0

    GO_VERSION=$(cat /tmp/go_version.txt 2>/dev/null)
    rm -f /tmp/go_version.txt
    whiptail --title "Go Installed" --msgbox "Go ${GO_VERSION} installed to $PERSIST/.go\n\nRun 'exec bash' to update PATH." 10 55
}

setup_nvm() {
    if [ -d "$PERSIST/.nvm" ]; then
        whiptail --title "NVM Already Installed" --yesno "NVM is already installed. Reinstall?" 8 50
        [ $? -ne 0 ] && return
        rm -rf "$PERSIST/.nvm"
    fi

    (
        echo 10
        echo "XXX"
        echo "Downloading NVM..."
        echo "XXX"
        mkdir -p "$PERSIST/.nvm"
        export NVM_DIR="$PERSIST/.nvm"
        curl -s -o- https://raw.githubusercontent.com/nvm-sh/nvm/master/install.sh | bash > /dev/null 2>&1

        echo 50
        echo "XXX"
        echo "Installing Node.js LTS..."
        echo "XXX"
        source "$PERSIST/.nvm/nvm.sh"
        nvm install --lts > /dev/null 2>&1

        echo 100
    ) | whiptail --title "Installing NVM + Node.js" --gauge "Preparing..." 8 60 0

    whiptail --title "NVM Installed" --msgbox "NVM installed to $PERSIST/.nvm\nNode LTS installed.\n\nRun 'exec bash' to update PATH." 10 55
}

setup_pgsql() {
    PG_VERSION="15"
    NEW_PGDATA="$PERSIST/postgres"

    # Check for existing PostgreSQL data (PG_VERSION file indicates valid cluster)
    if [ -f "$NEW_PGDATA/PG_VERSION" ]; then
        whiptail --title "PostgreSQL Already Setup" --yesno "PostgreSQL data directory exists. Reinitialize?\n\nWARNING: This will delete existing data!" 10 50
        [ $? -ne 0 ] && return
        sudo -u postgres /usr/lib/postgresql/${PG_VERSION}/bin/pg_ctl -D "$NEW_PGDATA" stop 2>/dev/null
        sudo /etc/init.d/postgresql stop 2>/dev/null
        rm -rf "$NEW_PGDATA"
    fi

    (
        echo 10
        echo "XXX"
        echo "Stopping existing PostgreSQL..."
        echo "XXX"
        sudo /etc/init.d/postgresql stop 2>/dev/null

        echo 30
        echo "XXX"
        echo "Creating data directory..."
        echo "XXX"
        mkdir -p "$NEW_PGDATA"
        sudo chown postgres:postgres "$NEW_PGDATA"
        sudo chmod 700 "$NEW_PGDATA"

        echo 50
        echo "XXX"
        echo "Initializing database cluster..."
        echo "XXX"
        sudo -u postgres /usr/lib/postgresql/${PG_VERSION}/bin/initdb -D "$NEW_PGDATA" > /dev/null 2>&1

        echo 80
        echo "XXX"
        echo "Starting PostgreSQL..."
        echo "XXX"
        sudo -u postgres /usr/lib/postgresql/${PG_VERSION}/bin/pg_ctl -D "$NEW_PGDATA" -l "$PERSIST/postgres/logfile" start > /dev/null 2>&1

        echo 100
    ) | whiptail --title "Setting up PostgreSQL" --gauge "Preparing..." 8 60 0

    whiptail --title "PostgreSQL Setup" --msgbox "PostgreSQL initialized in $PERSIST/postgres\n\nService is running." 10 55
}

setup_npm() {
    mkdir -p "$PERSIST/.npm"
    npm config set cache "$PERSIST/.npm" 2>/dev/null
    whiptail --title "NPM Cache" --msgbox "NPM cache set to $PERSIST/.npm" 8 55
}

setup_python_dev() {
    whiptail --title "Python Dev Tools" --yesno "Install Python development packages?\n\n- pdb++ (better debugger)\n- icecream (debug printing)\n- rich (beautiful output)\n- pytest + pytest-asyncio\n- uvicorn (ASGI server)\n- websockets, pydantic, loguru" 16 55
    [ $? -ne 0 ] && return

    (
        echo 0
        pip3 install --break-system-packages \
            pdbpp icecream rich \
            pytest pytest-asyncio \
            uvicorn gunicorn \
            websockets websocket-client \
            pydantic pyyaml \
            loguru structlog \
            aiohttp httpx > /dev/null 2>&1 &
        pid=$!

        while kill -0 $pid 2>/dev/null; do
            echo $((RANDOM % 40 + 30))
            sleep 1
        done
        wait $pid
        echo 100
    ) | whiptail --title "Installing Python Dev Tools" --gauge "Installing packages..." 8 60 0

    whiptail --title "Python Dev Tools" --msgbox "Python development packages installed!" 8 50
}

setup_audio_tools() {
    whiptail --title "Audio Tools" --yesno "Install audio/media tools?\n\n- ffmpeg (audio/video processing)\n- sox (sound processing)\n- pydub (Python audio)" 12 55
    [ $? -ne 0 ] && return

    (
        echo 20
        echo "XXX"
        echo "Installing ffmpeg and sox..."
        echo "XXX"
        apt-get update > /dev/null 2>&1
        apt-get install -y ffmpeg sox > /dev/null 2>&1

        echo 70
        echo "XXX"
        echo "Installing Python audio packages..."
        echo "XXX"
        pip3 install --break-system-packages pydub soundfile > /dev/null 2>&1

        echo 100
    ) | whiptail --title "Installing Audio Tools" --gauge "Preparing..." 8 60 0

    whiptail --title "Audio Tools" --msgbox "Audio tools installed!\n\nffmpeg, sox, pydub ready to use." 10 50
}

setup_ssh_key() {
    if [ -f "$PERSIST/.ssh/id_ed25519.pub" ]; then
        local pubkey=$(cat "$PERSIST/.ssh/id_ed25519.pub")

        # Show existing key in a textbox for easy copying
        local tmpfile=$(mktemp)
        {
            echo "Your current SSH public key:"
            echo ""
            echo "============================================================================"
            echo "$pubkey"
            echo "============================================================================"
            echo ""
            echo "Copy this key and add it to GitHub/GitLab/Bitbucket."
            echo ""
            echo "GitHub:    https://github.com/settings/keys"
            echo "GitLab:    https://gitlab.com/-/user_settings/ssh_keys"
            echo "Bitbucket: https://bitbucket.org/account/settings/ssh-keys/"
        } > "$tmpfile"

        whiptail --title " SSH Public Key " --textbox "$tmpfile" 18 80
        rm -f "$tmpfile"

        # Ask if they want to regenerate
        whiptail --title "Regenerate?" --yesno "Do you want to generate a NEW SSH key?\n\nThis will OVERWRITE your existing key!" 10 50
        [ $? -ne 0 ] && return
    fi

    local current_email=$(git config --global user.email 2>/dev/null)
    local email
    email=$(whiptail --inputbox "Email for SSH key:" 8 60 "$current_email" --title "SSH Key Setup" 3>&1 1>&2 2>&3)
    [ $? -ne 0 ] && return

    mkdir -p "$PERSIST/.ssh"
    chmod 700 "$PERSIST/.ssh"
    ssh-keygen -t ed25519 -C "$email" -f "$PERSIST/.ssh/id_ed25519" -N "" > /dev/null 2>&1

    rm -rf ~/.ssh
    ln -s "$PERSIST/.ssh" ~/.ssh

    local pubkey=$(cat "$PERSIST/.ssh/id_ed25519.pub")

    # Show new key in a textbox for easy copying
    local tmpfile=$(mktemp)
    {
        echo "SSH key generated! Here is your public key:"
        echo ""
        echo "============================================================================"
        echo "$pubkey"
        echo "============================================================================"
        echo ""
        echo "Copy this key and add it to GitHub/GitLab/Bitbucket."
        echo ""
        echo "GitHub:    https://github.com/settings/keys"
        echo "GitLab:    https://gitlab.com/-/user_settings/ssh_keys"
        echo "Bitbucket: https://bitbucket.org/account/settings/ssh-keys/"
    } > "$tmpfile"

    whiptail --title " SSH Key Generated " --textbox "$tmpfile" 18 80
    rm -f "$tmpfile"
}

setup_git_identity() {
    local current_name=$(git config --global user.name 2>/dev/null)
    local current_email=$(git config --global user.email 2>/dev/null)
    local current_token="${GITHUB_TOKEN:-}"

    local name
    name=$(whiptail --inputbox "Git user name:" 8 60 "$current_name" --title "Git Identity" 3>&1 1>&2 2>&3)
    [ $? -ne 0 ] && return

    local email
    email=$(whiptail --inputbox "Git email:" 8 60 "$current_email" --title "Git Identity" 3>&1 1>&2 2>&3)
    [ $? -ne 0 ] && return

    local github_token
    github_token=$(whiptail --inputbox "GitHub Personal Access Token (optional):\n\nUsed for: gh CLI, MCP github server, private repos" 10 70 "$current_token" --title "GitHub Token" 3>&1 1>&2 2>&3)
    [ $? -ne 0 ] && return

    mkdir -p "$PERSIST"
    cat > "$PERSIST/.gitconfig" << GITEOF
[user]
    name = $name
    email = $email
[init]
    defaultBranch = main
[core]
    editor = ${VISUAL:-vim}
[pull]
    rebase = false
GITEOF

    ln -sf "$PERSIST/.gitconfig" ~/.gitconfig

    # Save GitHub token to .env if provided
    if [ -n "$github_token" ]; then
        if [ -f "$PERSIST/.env" ]; then
            sed -i '/^GITHUB_TOKEN=/d' "$PERSIST/.env"
        fi
        echo "GITHUB_TOKEN=$github_token" >> "$PERSIST/.env"
        export GITHUB_TOKEN="$github_token"
    fi

    local msg="Git configured!\n\nName: $name\nEmail: $email"
    if [ -n "$github_token" ]; then
        msg+="\nGitHub Token: Saved to .env"
    fi
    whiptail --title "Git Identity" --msgbox "$msg" 12 50
}

setup_ai_keys() {
    # Show loading while checking OAuth status
    loading_screen "AI Setup" "Checking authentication status..." 1

    # Check if logged in via OAuth
    local claude_oauth=false
    local gemini_oauth=false
    local oauth_msg=""

    # Check Claude OAuth - credentials file with claudeAiOauth key
    if [ -f "$PERSIST/.claude/.credentials.json" ] && grep -q "claudeAiOauth" "$PERSIST/.claude/.credentials.json" 2>/dev/null; then
        claude_oauth=true
        oauth_msg+="Claude Code: OAuth logged in\n"
    fi

    # Check Gemini OAuth
    if [ -f "$PERSIST/.gemini/oauth_creds.json" ]; then
        gemini_oauth=true
        oauth_msg+="Gemini CLI: OAuth logged in\n"
    fi

    local anthropic_key="${ANTHROPIC_API_KEY:-}"
    local gemini_key="${GEMINI_API_KEY:-}"
    local slack_token="${SLACK_BOT_TOKEN:-}"
    local brave_key="${BRAVE_API_KEY:-}"

    # Only prompt for AI keys if not using OAuth for that service
    if [ "$claude_oauth" = false ]; then
        anthropic_key=$(whiptail --inputbox "Anthropic API Key (for Claude Code):" 8 70 "$anthropic_key" --title "AI API Keys" 3>&1 1>&2 2>&3)
        [ $? -ne 0 ] && return
    fi

    if [ "$gemini_oauth" = false ]; then
        gemini_key=$(whiptail --inputbox "Google Gemini API Key:" 8 70 "$gemini_key" --title "AI API Keys" 3>&1 1>&2 2>&3)
        [ $? -ne 0 ] && return
    fi

    # MCP server API keys (always prompt - not related to OAuth)
    slack_token=$(whiptail --inputbox "Slack Bot Token (optional, for MCP):" 8 70 "$slack_token" --title "MCP API Keys" 3>&1 1>&2 2>&3)
    [ $? -ne 0 ] && return

    brave_key=$(whiptail --inputbox "Brave Search API Key (optional, for MCP):" 8 70 "$brave_key" --title "MCP API Keys" 3>&1 1>&2 2>&3)
    [ $? -ne 0 ] && return

    # Save keys to .env
    if [ -f "$PERSIST/.env" ]; then
        sed -i '/^ANTHROPIC_API_KEY=/d' "$PERSIST/.env"
        sed -i '/^GEMINI_API_KEY=/d' "$PERSIST/.env"
        sed -i '/^SLACK_BOT_TOKEN=/d' "$PERSIST/.env"
        sed -i '/^BRAVE_API_KEY=/d' "$PERSIST/.env"
    fi

    if [ "$claude_oauth" = false ] && [ -n "$anthropic_key" ]; then
        echo "ANTHROPIC_API_KEY=\"$anthropic_key\"" >> "$PERSIST/.env"
        export ANTHROPIC_API_KEY="$anthropic_key"
    fi

    if [ "$gemini_oauth" = false ] && [ -n "$gemini_key" ]; then
        echo "GEMINI_API_KEY=\"$gemini_key\"" >> "$PERSIST/.env"
        export GEMINI_API_KEY="$gemini_key"
    fi

    if [ -n "$slack_token" ]; then
        echo "SLACK_BOT_TOKEN=\"$slack_token\"" >> "$PERSIST/.env"
        export SLACK_BOT_TOKEN="$slack_token"
    fi

    if [ -n "$brave_key" ]; then
        echo "BRAVE_API_KEY=\"$brave_key\"" >> "$PERSIST/.env"
        export BRAVE_API_KEY="$brave_key"
    fi

    whiptail --title "AI API Keys" --msgbox "API keys saved to $PERSIST/.env" 8 55
}

setup_mcp() {
    # Check if npx is available (should be from system Node in Docker image)
    if ! command -v npx >/dev/null 2>&1; then
        whiptail --title "Node.js Required" --msgbox "npx not found. Node.js should be pre-installed.\n\nTry rebuilding the container." 10 50
        return
    fi

    # Check what's available
    local has_claude=$(command -v claude >/dev/null 2>&1 && echo "yes" || echo "no")
    local has_gemini=$(command -v gemini >/dev/null 2>&1 && echo "yes" || echo "no")

    if [ "$has_claude" = "no" ] && [ "$has_gemini" = "no" ]; then
        whiptail --title "No AI CLI Found" --msgbox "Neither Claude Code nor Gemini CLI is installed.\n\nInstall one of them first:\n- claude: npm install -g @anthropic-ai/claude-code\n- gemini: npm install -g @anthropic-ai/gemini-cli" 12 60
        return
    fi

    local tools_msg=""
    [ "$has_claude" = "yes" ] && tools_msg+="- Claude Code\n"
    [ "$has_gemini" = "yes" ] && tools_msg+="- Gemini CLI\n"

    whiptail --title "MCP Servers" --msgbox "This will configure MCP servers for:\n\n${tools_msg}\nServers to be added:\n- filesystem (file operations)\n- memory (persistent notes)\n- sequential-thinking (reasoning)\n- serena (semantic code understanding)\n- ollama (local LLM via host Ollama)\n- postgres (if PostgreSQL configured)\n- github (if GITHUB_TOKEN set)\n- slack (if SLACK_BOT_TOKEN set)\n- brave-search (if BRAVE_API_KEY set)" 20 60

    # Install MCP servers using CLI commands
    clear
    echo "========================================"
    echo "Installing MCP Servers"
    echo "========================================"
    echo ""

    # Use system Node's npx (MCP servers spawn without shell context, so NVM paths won't work)
    # Always use /usr/bin/npx which is the system Node installed in the Docker image
    local NPX_PATH="/usr/bin/npx"
    if [ ! -x "$NPX_PATH" ]; then
        echo "ERROR: System npx not found at $NPX_PATH"
        echo "The Docker image should have Node.js pre-installed."
        read -p "Press Enter to continue..."
        return 1
    fi
    echo "Using npx: $NPX_PATH (system Node - required for MCP)"
    echo ""

    # Helper function to add server to both CLIs
    # Usage: add_mcp_server "name" [--env KEY=VALUE ...] -- command args...
    add_mcp_server() {
        local name="$1"
        shift

        # Parse --env arguments
        local claude_env_args=""
        local gemini_env_args=""
        while [ "$1" != "--" ] && [ $# -gt 0 ]; do
            if [ "$1" = "--env" ]; then
                shift
                claude_env_args+="--env $1 "
                gemini_env_args+="-e $1 "
                shift
            else
                shift
            fi
        done
        # Skip the "--" separator
        [ "$1" = "--" ] && shift

        echo "Adding $name..."

        if [ "$has_claude" = "yes" ]; then
            echo "  -> Claude Code"
            eval "claude mcp add --scope user \"$name\" $claude_env_args-- \"\$@\"" 2>/dev/null || true
        fi

        if [ "$has_gemini" = "yes" ]; then
            echo "  -> Gemini CLI"
            # Gemini CLI doesn't use -- separator, and uses -e for env vars
            eval "gemini mcp add -s user \"$name\" $gemini_env_args\"\$@\"" 2>/dev/null || true
        fi
        echo ""
    }

    # filesystem - file operations on /workdir
    add_mcp_server "filesystem" -- "$NPX_PATH" -y @modelcontextprotocol/server-filesystem /workdir

    # memory - persistent notes
    add_mcp_server "memory" -- "$NPX_PATH" -y @modelcontextprotocol/server-memory

    # sequential-thinking - step-by-step reasoning
    add_mcp_server "sequential-thinking" -- "$NPX_PATH" -y @modelcontextprotocol/server-sequential-thinking

    # postgres - only if configured (requires connection URL as argument)
    if [ -f "$PERSIST/postgres/PG_VERSION" ]; then
        add_mcp_server "postgres" -- "$NPX_PATH" -y @modelcontextprotocol/server-postgres postgresql://postgres@localhost/postgres
    fi

    # github - only if token set
    if [ -n "$GITHUB_TOKEN" ]; then
        add_mcp_server "github" --env GITHUB_TOKEN="$GITHUB_TOKEN" -- "$NPX_PATH" -y @modelcontextprotocol/server-github
    fi

    # slack - only if token set
    if [ -n "$SLACK_BOT_TOKEN" ]; then
        add_mcp_server "slack" --env SLACK_BOT_TOKEN="$SLACK_BOT_TOKEN" -- "$NPX_PATH" -y @modelcontextprotocol/server-slack
    fi

    # brave-search - only if API key set
    if [ -n "$BRAVE_API_KEY" ]; then
        add_mcp_server "brave-search" --env BRAVE_API_KEY="$BRAVE_API_KEY" -- "$NPX_PATH" -y @modelcontextprotocol/server-brave-search
    fi

    # serena - AI coding assistant with semantic code understanding
    # First install serena as a persistent uv tool, then add the MCP server
    echo "Installing Serena (this may take a moment)..."
    /usr/local/bin/uv tool install --force git+https://github.com/oraios/serena 2>/dev/null || true
    add_mcp_server "serena" -- $PERSIST/.local/bin/serena start-mcp-server

    # ollama - local LLM access via host Ollama
    # Uses OLLAMA_HOST env var (defaults to host.docker.internal:11434)
    local ollama_host="${OLLAMA_HOST:-http://host.docker.internal:11434}"
    add_mcp_server "ollama" --env OLLAMA_HOST="$ollama_host" -- "$NPX_PATH" -y ollama-mcp

    echo "========================================"
    echo "MCP Servers Installed!"
    echo "========================================"
    echo ""

    if [ "$has_claude" = "yes" ]; then
        echo "Claude Code servers:"
        claude mcp list 2>/dev/null || echo "  (run 'claude mcp list' to verify)"
        echo ""
    fi

    if [ "$has_gemini" = "yes" ]; then
        echo "Gemini CLI servers:"
        gemini mcp list 2>/dev/null || echo "  (run 'gemini mcp list' to verify)"
        echo ""
    fi

    read -p "Press Enter to continue..."
}

remove_mcp() {
    # Check what's available
    local has_claude=$(command -v claude >/dev/null 2>&1 && echo "yes" || echo "no")
    local has_gemini=$(command -v gemini >/dev/null 2>&1 && echo "yes" || echo "no")

    if [ "$has_claude" = "no" ] && [ "$has_gemini" = "no" ]; then
        whiptail --title "No AI CLI Found" --msgbox "Neither Claude Code nor Gemini CLI is installed." 8 50
        return
    fi

    # Get list of servers
    local servers=""
    if [ "$has_claude" = "yes" ]; then
        servers=$(claude mcp list 2>/dev/null | grep -E "^\s+\w+" | awk '{print $1}' | sort -u)
    fi
    if [ "$has_gemini" = "yes" ]; then
        local gemini_servers=$(gemini mcp list 2>/dev/null | grep -E "^\s+\w+" | awk '{print $1}' | sort -u)
        servers=$(echo -e "$servers\n$gemini_servers" | sort -u | grep -v '^$')
    fi

    if [ -z "$servers" ]; then
        whiptail --title "No MCP Servers" --msgbox "No MCP servers are currently configured." 8 50
        return
    fi

    # Build menu options
    local menu_items=""
    local count=1
    for server in $servers; do
        menu_items+="\"$count\" \"$server\" "
        count=$((count + 1))
    done

    local choice
    choice=$(eval "whiptail --title \"Remove MCP Server\" --menu \"Select server to remove:\" 20 50 10 $menu_items" 3>&1 1>&2 2>&3)
    [ $? -ne 0 ] && return

    # Get server name from choice
    local server_name=$(echo "$servers" | sed -n "${choice}p")

    if whiptail --title "Confirm Removal" --yesno "Remove MCP server '$server_name' from all tools?" 8 50; then
        clear
        echo "Removing $server_name..."

        if [ "$has_claude" = "yes" ]; then
            echo "  -> Claude Code"
            claude mcp remove "$server_name" 2>/dev/null || true
        fi

        if [ "$has_gemini" = "yes" ]; then
            echo "  -> Gemini CLI"
            gemini mcp remove "$server_name" 2>/dev/null || true
        fi

        echo ""
        echo "Done!"
        read -p "Press Enter to continue..."
    fi
}

fix_mcp() {
    # Fix common MCP server issues:
    # 1. Clear corrupted npm cache
    # 2. Fix npx paths to use system Node instead of NVM paths

    local has_claude=$(command -v claude >/dev/null 2>&1 && echo "yes" || echo "no")
    local has_gemini=$(command -v gemini >/dev/null 2>&1 && echo "yes" || echo "no")

    if [ "$has_claude" = "no" ] && [ "$has_gemini" = "no" ]; then
        whiptail --title "No AI CLI Found" --msgbox "Neither Claude Code nor Gemini CLI is installed." 8 50
        return
    fi

    # Confirm fix
    if ! whiptail --title "Fix MCP Servers" --yesno "This will:\n\n1. Clear corrupted npm/npx cache\n2. Fix npx paths to use /usr/bin/npx\n3. Fix uvx paths to use /usr/local/bin/uvx\n\nThis fixes 'Failed to connect' errors caused by:\n- NVM path issues (MCP servers spawn without shell)\n- Corrupted npm cache\n\nProceed?" 17 60; then
        return
    fi

    clear
    echo "========================================"
    echo "Fixing MCP Servers"
    echo "========================================"
    echo ""

    # Step 1: Clear npm cache
    echo "Step 1: Clearing npm/npx cache..."
    if [ -d "$PERSIST/.npm/_npx" ]; then
        rm -rf "$PERSIST/.npm/_npx"
        echo "  -> Cleared $PERSIST/.npm/_npx"
    else
        echo "  -> Cache directory not found (OK)"
    fi
    echo ""

    # Step 2: Fix Claude config
    if [ "$has_claude" = "yes" ]; then
        echo "Step 2: Fixing Claude Code MCP config..."
        local claude_config="/root/.claude.json"
        if [ -f "$claude_config" ]; then
            # Check if there are any MCP servers configured
            local server_count=$(jq '.mcpServers | keys | length' "$claude_config" 2>/dev/null || echo "0")
            if [ "$server_count" -gt 0 ]; then
                # Fix all command paths: npx -> /usr/bin/npx, uvx -> /usr/local/bin/uvx
                jq '(.mcpServers | to_entries | map(
                    if (.value.command | test("npx$")) then
                        .value.command = "/usr/bin/npx"
                    elif (.value.command | test("uvx$")) then
                        .value.command = "/usr/local/bin/uvx"
                    else .
                    end
                ) | from_entries) as $fixed | .mcpServers = $fixed' "$claude_config" > /tmp/claude_fix.json
                if [ -s /tmp/claude_fix.json ]; then
                    mv /tmp/claude_fix.json "$claude_config"
                    echo "  -> Fixed $server_count server(s)"
                else
                    echo "  -> No changes needed"
                fi
            else
                echo "  -> No MCP servers configured"
            fi
        else
            echo "  -> Config file not found"
        fi
        echo ""
    fi

    # Step 3: Fix Gemini config
    if [ "$has_gemini" = "yes" ]; then
        echo "Step 3: Fixing Gemini CLI MCP config..."
        local gemini_config="/root/.gemini/settings.json"
        if [ -f "$gemini_config" ]; then
            local server_count=$(jq '.mcpServers | keys | length' "$gemini_config" 2>/dev/null || echo "0")
            if [ "$server_count" -gt 0 ]; then
                jq '(.mcpServers | to_entries | map(
                    if (.value.command | test("npx$")) then
                        .value.command = "/usr/bin/npx"
                    elif (.value.command | test("uvx$")) then
                        .value.command = "/usr/local/bin/uvx"
                    else .
                    end
                ) | from_entries) as $fixed | .mcpServers = $fixed' "$gemini_config" > /tmp/gemini_fix.json
                if [ -s /tmp/gemini_fix.json ]; then
                    mv /tmp/gemini_fix.json "$gemini_config"
                    echo "  -> Fixed $server_count server(s)"
                else
                    echo "  -> No changes needed"
                fi
            else
                echo "  -> No MCP servers configured"
            fi
        else
            echo "  -> Config file not found"
        fi
        echo ""
    fi

    # Step 4: Verify
    echo "========================================"
    echo "Verifying MCP Servers"
    echo "========================================"
    echo ""

    if [ "$has_claude" = "yes" ]; then
        echo "Claude Code servers:"
        claude mcp list 2>/dev/null || echo "  (unable to list)"
        echo ""
    fi

    if [ "$has_gemini" = "yes" ]; then
        echo "Gemini CLI servers:"
        gemini mcp list 2>/dev/null || echo "  (unable to list)"
        echo ""
    fi

    read -p "Press Enter to continue..."
}

setup_nanocoder() {
    # Configure NanoCoder with Ollama provider and MCP servers

    if ! command -v nanocoder >/dev/null 2>&1; then
        whiptail --title "NanoCoder Not Found" --msgbox "NanoCoder is not installed.\n\nIt should be pre-installed in the container." 10 50
        return
    fi

    local ollama_host="${OLLAMA_HOST:-http://host.docker.internal:11434}"

    # Check Ollama connection
    local ollama_status="not connected"
    local models=""
    if curl -s --connect-timeout 2 "$ollama_host/api/tags" > /dev/null 2>&1; then
        ollama_status="connected"
        models=$(curl -s "$ollama_host/api/tags" | jq -r '.models[].name' 2>/dev/null | head -5 | tr '\n' ', ' | sed 's/,$//')
    fi

    # Check OpenRouter
    local openrouter_info=""
    if [ -n "$OPENROUTER_API_KEY" ]; then
        openrouter_info="\n\n• OpenRouter provider: configured\n  Models: claude-3.5-sonnet, gpt-4o, llama-3.1, etc."
    fi

    if ! whiptail --title "Setup NanoCoder" --yesno "This will configure NanoCoder with:\n\n• Ollama provider: $ollama_host\n  Status: $ollama_status\n  Models: auto-detect tool-capable models${openrouter_info}\n\n• MCP Servers:\n  - filesystem, memory, sequential-thinking\n  - ollama, serena\n  - postgres (if configured), github (if token set)\n\nProceed?" 22 65; then
        return
    fi

    clear
    echo "========================================"
    echo "Configuring NanoCoder"
    echo "========================================"
    echo ""

    # Create config directory
    mkdir -p "$PERSIST/.nanocoder"

    # Build MCP servers config
    local mcp_servers='[
    {
      "name": "filesystem",
      "transport": "stdio",
      "command": "/usr/bin/npx",
      "args": ["-y", "@modelcontextprotocol/server-filesystem", "/workdir"]
    },
    {
      "name": "memory",
      "transport": "stdio",
      "command": "/usr/bin/npx",
      "args": ["-y", "@modelcontextprotocol/server-memory"]
    },
    {
      "name": "sequential-thinking",
      "transport": "stdio",
      "command": "/usr/bin/npx",
      "args": ["-y", "@modelcontextprotocol/server-sequential-thinking"]
    },
    {
      "name": "ollama",
      "transport": "stdio",
      "command": "/usr/bin/npx",
      "args": ["-y", "ollama-mcp"],
      "env": {"OLLAMA_HOST": "'"$ollama_host"'"}
    },
    {
      "name": "serena",
      "transport": "stdio",
      "command": "'"$PERSIST"'/.local/bin/serena",
      "args": ["start-mcp-server"]
    }'

    # Add postgres if configured
    if [ -f "$PERSIST/postgres/PG_VERSION" ]; then
        mcp_servers+=',
    {
      "name": "postgres",
      "transport": "stdio",
      "command": "/usr/bin/npx",
      "args": ["-y", "@modelcontextprotocol/server-postgres", "postgresql://postgres@localhost/postgres"]
    }'
    fi

    # Add github if token set
    if [ -n "$GITHUB_TOKEN" ]; then
        mcp_servers+=',
    {
      "name": "github",
      "transport": "stdio",
      "command": "/usr/bin/npx",
      "args": ["-y", "@modelcontextprotocol/server-github"],
      "env": {"GITHUB_TOKEN": "'"$GITHUB_TOKEN"'"}
    }'
    fi

    mcp_servers+='
  ]'

    # Detect Ollama models that support tools
    echo "Detecting Ollama models with tool support..."
    local tool_models=""
    if curl -s --connect-timeout 2 "$ollama_host/api/tags" > /dev/null 2>&1; then
        # Get list of models and check each for tool support
        local all_models=$(curl -s "$ollama_host/api/tags" | jq -r '.models[].name' 2>/dev/null)
        for model in $all_models; do
            # Check if model supports tools by querying its info
            if curl -s "$ollama_host/api/show" -d "{\"name\":\"$model\"}" 2>/dev/null | grep -qi "tools"; then
                [ -n "$tool_models" ] && tool_models+=", "
                tool_models+="\"$model\""
                echo "  [+] $model (supports tools)"
            else
                echo "  [ ] $model"
            fi
        done
    fi
    # Fallback to common tool-capable models if none detected
    [ -z "$tool_models" ] && tool_models='"qwen2.5-coder:latest", "llama3.1:latest"'
    echo ""

    # Build providers array
    local providers='[
      {
        "name": "Ollama",
        "baseUrl": "'"${ollama_host}"'/v1",
        "models": ['"$tool_models"']
      }'

    # Add OpenRouter if API key is set
    if [ -n "$OPENROUTER_API_KEY" ]; then
        providers+=',
      {
        "name": "OpenRouter",
        "baseUrl": "https://openrouter.ai/api/v1",
        "apiKey": "'"$OPENROUTER_API_KEY"'",
        "models": ["anthropic/claude-3.5-sonnet", "openai/gpt-4o", "meta-llama/llama-3.1-70b-instruct", "mistralai/mistral-large"]
      }'
    fi

    providers+='
    ]'

    # Create the config file
    cat > "$PERSIST/.nanocoder/agents.config.json" << NANOCFG
{
  "nanocoder": {
    "providers": $providers,
    "mcpServers": $mcp_servers
  }
}
NANOCFG

    echo "Created config: $PERSIST/.nanocoder/agents.config.json"
    echo ""
    echo "Providers:"
    echo "  - Ollama at $ollama_host"
    [ -n "$OPENROUTER_API_KEY" ] && echo "  - OpenRouter (cloud models)"
    echo ""
    echo "MCP Servers configured:"
    jq -r '.nanocoder.mcpServers[].name' "$PERSIST/.nanocoder/agents.config.json" 2>/dev/null | sed 's/^/  - /'
    echo ""
    echo "To use: run 'nanocoder' and select a model"
    echo "To customize: edit $PERSIST/.nanocoder/agents.config.json"
    echo ""

    read -p "Press Enter to continue..."
}

setup_freeswitch() {
    # Check token access by testing against the repos
    loading_screen "FreeSWITCH" "Checking token access..." 1

    local has_enterprise=false
    local has_community=false
    local enterprise_token=""
    local community_token=""

    # Test SIGNALWIRE_TOKEN for Enterprise access
    if [ -n "$SIGNALWIRE_TOKEN" ]; then
        echo "machine fsa.freeswitch.com login signalwire password $SIGNALWIRE_TOKEN" > /tmp/fs_netrc_test
        local response=$(curl -s -o /dev/null -w "%{http_code}" --netrc-file /tmp/fs_netrc_test "https://fsa.freeswitch.com/repo/deb/fsa/keyring.gpg" 2>/dev/null)
        if [ "$response" = "200" ]; then
            has_enterprise=true
            enterprise_token="$SIGNALWIRE_TOKEN"
        fi
        rm -f /tmp/fs_netrc_test
    fi

    # Test FREESWITCH_PAT for Community access
    if [ -n "$FREESWITCH_PAT" ]; then
        echo "machine freeswitch.signalwire.com login signalwire password $FREESWITCH_PAT" > /tmp/fs_netrc_test
        local response=$(curl -s -o /dev/null -w "%{http_code}" --netrc-file /tmp/fs_netrc_test "https://freeswitch.signalwire.com/repo/deb/debian-release/signalwire-freeswitch-repo.gpg" 2>/dev/null)
        if [ "$response" = "200" ]; then
            has_community=true
            community_token="$FREESWITCH_PAT"
        fi
        rm -f /tmp/fs_netrc_test
    fi

    # Test SIGNALWIRE_TOKEN for Community access (if PAT didn't work)
    if [ "$has_community" = false ] && [ -n "$SIGNALWIRE_TOKEN" ]; then
        echo "machine freeswitch.signalwire.com login signalwire password $SIGNALWIRE_TOKEN" > /tmp/fs_netrc_test
        local response=$(curl -s -o /dev/null -w "%{http_code}" --netrc-file /tmp/fs_netrc_test "https://freeswitch.signalwire.com/repo/deb/debian-release/signalwire-freeswitch-repo.gpg" 2>/dev/null)
        if [ "$response" = "200" ]; then
            has_community=true
            community_token="$SIGNALWIRE_TOKEN"
        fi
        rm -f /tmp/fs_netrc_test
    fi

    # Build menu options based on what's available
    local menu_options=()
    if [ "$has_enterprise" = true ]; then
        menu_options+=("enterprise" "FreeSWITCH Enterprise (access verified)")
    fi
    if [ "$has_community" = true ]; then
        menu_options+=("community" "FreeSWITCH Community/OSS (access verified)")
    fi

    if [ ${#menu_options[@]} -eq 0 ]; then
        whiptail --title "No Access" --msgbox "No valid FreeSWITCH access found.\n\nFor Enterprise:\n- SIGNALWIRE_TOKEN needs 'FreeSWITCH Access' scope\n- Contact sales@signalwire.com for access\n\nFor Community:\n- Get a FREESWITCH_PAT from signalwire.com\n\nUse option 1 to set up credentials." 16 65
        return 1
    fi

    local edition
    edition=$(whiptail --title "FreeSWITCH Edition" --menu "Select FreeSWITCH edition:\n(Only editions your tokens have access to are shown)" 14 70 ${#menu_options[@]} \
        "${menu_options[@]}" \
        3>&1 1>&2 2>&3)
    [ $? -ne 0 ] && return

    local token=""
    if [ "$edition" = "enterprise" ]; then
        token="$enterprise_token"
    else
        token="$community_token"
    fi

    # Choose release channel
    local channel
    channel=$(whiptail --title "FreeSWITCH Channel" --menu "Select release channel:" 12 50 2 \
        "release" "Stable release (recommended)" \
        "prerelease" "Pre-release / testing" \
        3>&1 1>&2 2>&3)
    [ $? -ne 0 ] && return

    # Run the installer with visible output
    clear
    echo "========================================"
    echo "Installing FreeSWITCH ($channel)"
    echo "========================================"
    echo ""

    curl -sSL https://freeswitch.org/fsget | bash -s "$token" "$channel" install
    local status=$?

    echo ""
    if [ $status -eq 0 ]; then
        echo "Starting FreeSWITCH..."
        # No systemd in container, start manually in background
        freeswitch -nonat -nocal -nc
        sleep 2
        if pgrep -x freeswitch > /dev/null; then
            echo ""
            echo "========================================"
            echo "Installation completed! FreeSWITCH is running."
            echo "========================================"
        else
            echo ""
            echo "========================================"
            echo "Installation completed but FreeSWITCH failed to start."
            echo "Try running: freeswitch -nonat -nocal -nc"
            echo "========================================"
        fi
    else
        echo "========================================"
        echo "Installation finished with exit code: $status"
        echo "========================================"
    fi
    echo ""
    read -p "Press Enter to continue..."
}

uninstall_freeswitch() {
    # Check if FreeSWITCH is installed
    if ! command -v freeswitch &>/dev/null && [ ! -d "/usr/share/freeswitch" ] && [ ! -d "/etc/freeswitch" ]; then
        whiptail --title "Not Installed" --msgbox "FreeSWITCH does not appear to be installed." 8 50
        return
    fi

    if ! whiptail --title "Uninstall FreeSWITCH" --yesno "This will completely remove FreeSWITCH including:\n\n- All packages (freeswitch*)\n- Configuration files (/etc/freeswitch)\n- Data files (/usr/share/freeswitch)\n- Log files (/var/log/freeswitch)\n\nAre you sure?" 16 60; then
        return
    fi

    clear
    echo "========================================"
    echo "Uninstalling FreeSWITCH"
    echo "========================================"
    echo ""

    echo "Stopping FreeSWITCH..."
    pkill -x freeswitch 2>/dev/null || killall freeswitch 2>/dev/null || true
    sleep 2

    echo "Removing packages..."
    apt-get purge -y 'freeswitch*' 2>/dev/null || yum remove -y 'freeswitch*' 2>/dev/null || true
    apt-get autoremove -y 2>/dev/null || true

    echo "Removing configuration and data files..."
    rm -rf /etc/freeswitch
    rm -rf /usr/share/freeswitch
    rm -rf /var/log/freeswitch
    rm -rf /var/lib/freeswitch
    rm -rf /var/run/freeswitch

    echo ""
    echo "========================================"
    echo "FreeSWITCH has been uninstalled."
    echo "========================================"
    echo ""
    read -p "Press Enter to continue..."
}

toggle_swsh() {
    if [ -f "$PERSIST/.noswsh" ]; then
        # Currently disabled, offer to enable
        if whiptail --title "SignalWire Shell" --yesno "swsh is currently DISABLED on login.\n\nEnable swsh to start automatically?" 10 55; then
            rm -f "$PERSIST/.noswsh"
            whiptail --title "swsh Enabled" --msgbox "swsh will now start on login.\n\nRun 'exec bash' to test." 10 50
        fi
    else
        # Currently enabled, offer to disable
        if whiptail --title "SignalWire Shell" --yesno "swsh is currently ENABLED on login.\n\nDisable swsh auto-start?\n\n(You can still run 'swsh' manually)" 12 55; then
            touch "$PERSIST/.noswsh"
            whiptail --title "swsh Disabled" --msgbox "swsh will no longer start on login.\n\nRun 'swsh' manually when needed." 10 50
        fi
    fi
}

clean_environment() {
    CLEAN_CHOICE=$(whiptail --title "Clean Environment" --menu "What do you want to clean?" 16 60 6 \
        "1" "Clean all Python venvs" \
        "2" "Clean NPM cache" \
        "3" "Clean pip cache" \
        "4" "Clean all caches" \
        "5" "Clean AI configs (Claude/Gemini)" \
        "6" "Full reset (remove all dev tools + AI)" \
        3>&1 1>&2 2>&3)

    [ $? -ne 0 ] && return

    case $CLEAN_CHOICE in
        "1")
            if whiptail --title "Confirm" --yesno "Delete ALL Python virtual environments?" 8 50; then
                rm -rf "$PERSIST/.venvs"
                mkdir -p "$PERSIST/.venvs"
                whiptail --title "Cleaned" --msgbox "All venvs deleted." 8 40
            fi
            ;;
        "2")
            rm -rf "$PERSIST/.npm"/*
            whiptail --title "Cleaned" --msgbox "NPM cache cleared." 8 40
            ;;
        "3")
            pip3 cache purge 2>/dev/null
            whiptail --title "Cleaned" --msgbox "Pip cache cleared." 8 40
            ;;
        "4")
            rm -rf "$PERSIST/.npm"/*
            pip3 cache purge 2>/dev/null
            whiptail --title "Cleaned" --msgbox "All caches cleared." 8 40
            ;;
        "5")
            if whiptail --title "Confirm" --yesno "This will remove:\n\n- Claude Code config (.claude/)\n- Gemini CLI config (.gemini/)\n- AI API keys from .env\n\nYou will need to re-login or re-enter API keys." 14 55; then
                rm -rf "$PERSIST/.claude" "$PERSIST/.gemini"
                if [ -f "$PERSIST/.env" ]; then
                    sed -i '/^ANTHROPIC_API_KEY=/d' "$PERSIST/.env"
                    sed -i '/^GEMINI_API_KEY=/d' "$PERSIST/.env"
                fi
                unset ANTHROPIC_API_KEY GEMINI_API_KEY
                whiptail --title "Cleaned" --msgbox "AI configs removed.\n\nRun 'claude login' or setup AI keys." 10 50
            fi
            ;;
        "6")
            if whiptail --title "DANGER" --yesno "This will remove:\n\n- All venvs\n- Go installation\n- NVM + Node\n- PostgreSQL data\n- All caches\n- Claude/Gemini configs\n- AI API keys\n\nCredentials and SSH keys kept.\n\nAre you SURE?" 20 50; then
                rm -rf "$PERSIST/.venvs" "$PERSIST/.go" "$PERSIST/.nvm" "$PERSIST/.npm" "$PERSIST/postgres"
                rm -rf "$PERSIST/.claude" "$PERSIST/.gemini"
                if [ -f "$PERSIST/.env" ]; then
                    sed -i '/^ANTHROPIC_API_KEY=/d' "$PERSIST/.env"
                    sed -i '/^GEMINI_API_KEY=/d' "$PERSIST/.env"
                fi
                pip3 cache purge 2>/dev/null
                unset ANTHROPIC_API_KEY GEMINI_API_KEY
                whiptail --title "Reset Complete" --msgbox "Environment reset.\n\nRun 'exec bash' then 'setup' to reinstall." 10 50
            fi
            ;;
    esac
}

setup_all() {
    whiptail --title "Setup All" --yesno "This will setup:\n\n- Go (latest)\n- NVM + Node LTS\n- PostgreSQL\n- NPM cache\n- Python dev tools\n\nContinue?" 16 50
    [ $? -ne 0 ] && return

    setup_golang
    setup_nvm
    setup_pgsql
    setup_npm
    setup_python_dev

    whiptail --title "Setup Complete" --msgbox "All development tools installed!\n\nRun 'exec bash' to update environment." 10 50
}

show_status() {
    # Gather data first
    local ngrok_url=$(curl -s http://127.0.0.1:4040/api/tunnels 2>/dev/null | jq -r '.tunnels[0].public_url // empty' 2>/dev/null)
    local py_ver=$(python3 --version 2>/dev/null | awk '{print $2}')
    local go_ver="" node_ver=""
    [ -d "$PERSIST/.go" ] && go_ver=$("$PERSIST/.go/bin/go" version 2>/dev/null | awk '{print $3}' | sed 's/go//')
    [ -f "$PERSIST/.nvm/nvm.sh" ] && node_ver=$(source "$PERSIST/.nvm/nvm.sh" 2>/dev/null && node --version 2>/dev/null)
    local git_name=$(git config --global user.name 2>/dev/null)
    local uptime=$(awk '{printf "%dd %dh %dm", $1/86400, ($1%86400)/3600, ($1%3600)/60}' /proc/uptime 2>/dev/null)

    # Claude MCP servers
    local claude_mcp=""
    if [ -f "/root/.claude.json" ]; then
        claude_mcp=$(jq -r '.mcpServers // {} | keys | join(", ")' /root/.claude.json 2>/dev/null)
    fi
    [ -z "$claude_mcp" ] && claude_mcp="(none)"

    # Gemini MCP servers
    local gemini_mcp=""
    if [ -f "$PERSIST/.gemini/settings.json" ]; then
        gemini_mcp=$(jq -r '.mcpServers // {} | keys | join(", ")' "$PERSIST/.gemini/settings.json" 2>/dev/null)
    fi
    [ -z "$gemini_mcp" ] && gemini_mcp="(none)"

    # NanoCoder MCP servers
    local nanocoder_mcp=""
    if [ -f "$PERSIST/.nanocoder/agents.config.json" ]; then
        nanocoder_mcp=$(jq -r '.nanocoder.mcpServers // [] | map(.name) | join(", ")' "$PERSIST/.nanocoder/agents.config.json" 2>/dev/null)
    fi
    [ -z "$nanocoder_mcp" ] && nanocoder_mcp="(none)"

    # Build status using a temp file for reliable whiptail display
    local tmpfile=$(mktemp)
    {
        # Public URL header if available
        [ -n "$ngrok_url" ] && echo "  Public URL: ${ngrok_url}" && echo ""

        echo "  SERVICES                              AUTHENTICATION"
        echo "  ====================================  ===================================="

        # Services column data
        local svc1="  " svc2="  " svc3="  " svc4="  " svc5="  " svc6="  " svc7="  "
        pgrep -x redis-server >/dev/null 2>&1 && svc1+="[*] Redis" || svc1+="[ ] Redis"
        pgrep -x nginx >/dev/null 2>&1 && svc2+="[*] nginx" || svc2+="[ ] nginx"
        if [ -n "$NGROK_TOKEN" ]; then
            [ -n "$ngrok_url" ] && svc3+="[*] ngrok" || svc3+="[!] ngrok (stopped)"
        else
            svc3+="[ ] ngrok"
        fi
        # Cloudflare Tunnel status
        if [ -f "$PERSIST/.cloudflared/token" ]; then
            if tmux has-session -t cloudflared 2>/dev/null; then
                svc4+="[*] Cloudflare Tunnel"
            else
                svc4+="[!] Cloudflare Tunnel (stopped)"
            fi
        else
            svc4+="[ ] Cloudflare Tunnel"
        fi
        pgrep -x freeswitch >/dev/null 2>&1 && svc5+="[*] FreeSWITCH" || svc5+="[ ] FreeSWITCH"
        pgrep -x postgres >/dev/null 2>&1 && svc6+="[*] PostgreSQL" || svc6+="[ ] PostgreSQL"
        [ -S /var/run/docker.sock ] && svc7+="[*] Docker" || svc7+="[ ] Docker"
        # Ollama (check if host is reachable) - URL shown on separate line
        local svc8="  "
        local ollama_url_display=""
        local ollama_check_host="${OLLAMA_HOST:-http://host.docker.internal:11434}"
        if curl -s --connect-timeout 1 "$ollama_check_host/api/tags" > /dev/null 2>&1; then
            svc8+="[*] Ollama"
            ollama_url_display="       -> $ollama_check_host"
        elif [ -n "$OLLAMA_HOST" ]; then
            svc8+="[!] Ollama (not reachable)"
            ollama_url_display="       -> $OLLAMA_HOST"
        else
            svc8+="[ ] Ollama"
        fi

        # Auth column data
        local auth1="" auth2="" auth3="" auth4="" auth5="" auth6="" auth7=""
        if [ -f "$PERSIST/.claude/.credentials.json" ] && grep -q "claudeAiOauth" "$PERSIST/.claude/.credentials.json" 2>/dev/null; then
            auth1="[*] Claude (OAuth)"
        elif [ -n "$ANTHROPIC_API_KEY" ]; then
            auth1="[*] Claude (API Key)"
        else
            auth1="[ ] Claude"
        fi
        if [ -f "$PERSIST/.gemini/oauth_creds.json" ]; then
            auth2="[*] Gemini (OAuth)"
        elif [ -n "$GEMINI_API_KEY" ]; then
            auth2="[*] Gemini (API Key)"
        else
            auth2="[ ] Gemini"
        fi
        [ -n "$GITHUB_TOKEN" ] && auth3="[*] GitHub Token" || auth3="[ ] GitHub Token"
        [ -n "$SLACK_BOT_TOKEN" ] && auth4="[*] Slack Token" || auth4="[ ] Slack Token"
        [ -n "$BRAVE_API_KEY" ] && auth5="[*] Brave API Key" || auth5="[ ] Brave API Key"
        [ -n "$FREESWITCH_PAT" ] && auth6="[*] FreeSWITCH PAT" || auth6="[ ] FreeSWITCH PAT"
        # NanoCoder - check if configured
        if [ -f "$PERSIST/.nanocoder/agents.config.json" ]; then
            auth7="[*] NanoCoder (configured)"
        else
            auth7="[ ] NanoCoder"
        fi
        # OpenRouter - check if API key set
        [ -n "$OPENROUTER_API_KEY" ] && auth8="[*] OpenRouter API Key" || auth8="[ ] OpenRouter"

        printf "%-40s%s\n" "$svc1" "$auth1"
        printf "%-40s%s\n" "$svc2" "$auth2"
        printf "%-40s%s\n" "$svc3" "$auth3"
        printf "%-40s%s\n" "$svc4" "$auth4"
        printf "%-40s%s\n" "$svc5" "$auth5"
        printf "%-40s%s\n" "$svc6" "$auth6"
        printf "%-40s%s\n" "$svc7" "$auth7"
        printf "%-40s%s\n" "$svc8" "$auth8"
        [ -n "$ollama_url_display" ] && echo "$ollama_url_display"

        echo ""
        echo "  CONFIGURATION                         DEV TOOLS"
        echo "  ====================================  ===================================="

        # Config column
        local cfg1="  " cfg2="  " cfg3="  " cfg4="  "
        [ -n "$SIGNALWIRE_SPACE_NAME" ] && cfg1+="[*] SignalWire ($SIGNALWIRE_SPACE_NAME)" || cfg1+="[ ] SignalWire"
        cfg2+="[*] Editor: ${VISUAL:-vim}"
        [ -f "$PERSIST/.ssh/id_ed25519" ] && cfg3+="[*] SSH Key" || cfg3+="[ ] SSH Key"
        [ -n "$git_name" ] && cfg4+="[*] Git ($git_name)" || cfg4+="[ ] Git Identity"

        # Dev tools column
        local dev1="[*] Python $py_ver"
        local dev2="" dev3="" dev4=""
        [ -n "$go_ver" ] && dev2="[*] Go $go_ver" || dev2="[ ] Go"
        [ -n "$node_ver" ] && dev3="[*] Node.js $node_ver" || dev3="[ ] Node.js"
        [ -n "$NGROK_ARGS" ] && dev4="[*] NGROK Args" || dev4="[ ] NGROK Args"

        printf "%-40s%s\n" "$cfg1" "$dev1"
        printf "%-40s%s\n" "$cfg2" "$dev2"
        printf "%-40s%s\n" "$cfg3" "$dev3"
        printf "%-40s%s\n" "$cfg4" "$dev4"

        echo ""
        echo "  MCP SERVERS"
        echo "  ============================================================================"
        echo "  Claude:    $claude_mcp"
        echo "  Gemini:    $gemini_mcp"
        echo "  NanoCoder: $nanocoder_mcp"
        echo ""
        echo "  ============================================================================"
        echo "  Uptime: $uptime"

    } > "$tmpfile"

    whiptail --title " WireStarter Environment Status " --scrolltext --textbox "$tmpfile" 30 90
    rm -f "$tmpfile"
}

# Main menu loop - Cancel button exits
while true; do
    # Check ngrok status for menu
    ngrok_status="Start ngrok Tunnel"
    if curl -s http://127.0.0.1:4040/api/tunnels > /dev/null 2>&1; then
        ngrok_status="ngrok Running (restart)"
    fi

    # Check swsh status for menu
    swsh_status="Disable swsh on Login"
    if [ -f "$PERSIST/.noswsh" ]; then
        swsh_status="Enable swsh on Login"
    fi

    # Check cloudflare tunnel status
    cf_status="Setup Cloudflare Tunnel"
    if [ -f "$PERSIST/.cloudflared/token" ]; then
        if tmux has-session -t cloudflared 2>/dev/null; then
            cf_status="Cloudflare Tunnel (running)"
        else
            cf_status="Cloudflare Tunnel (configured)"
        fi
    fi

    CHOICE=$(whiptail --title "WireStarter Environment Setup" --menu "Select an option (Cancel to exit):" 32 60 22 \
        "1" "Setup SignalWire & NGROK Credentials" \
        "2" "$ngrok_status" \
        "3" "$cf_status" \
        "4" "Setup AI API Keys (Claude/Gemini)" \
        "5" "Add MCP Servers (Claude/Gemini)" \
        "6" "Remove MCP Server" \
        "7" "Fix MCP Servers (connection issues)" \
        "8" "Setup NanoCoder (Ollama + MCP)" \
        "9" "Setup Git Identity" \
        "10" "Setup SSH Key" \
        "11" "Setup Go (latest stable)" \
        "12" "Setup NVM + Node.js" \
        "13" "Setup PostgreSQL" \
        "14" "Setup FreeSWITCH" \
        "15" "Uninstall FreeSWITCH" \
        "16" "Setup Python Dev Tools" \
        "17" "Setup Audio Tools (ffmpeg/sox)" \
        "18" "Setup All Dev Tools" \
        "19" "$swsh_status" \
        "20" "Show Status" \
        "21" "Clean Environment" \
        3>&1 1>&2 2>&3)

    # Cancel button or ESC exits
    [ $? -ne 0 ] && exit 0

    case $CHOICE in
        "1") setup_credentials ;;
        "2") start_ngrok ;;
        "3") setup_cloudflare_tunnel ;;
        "4") setup_ai_keys ;;
        "5") setup_mcp ;;
        "6") remove_mcp ;;
        "7") fix_mcp ;;
        "8") setup_nanocoder ;;
        "9") setup_git_identity ;;
        "10") setup_ssh_key ;;
        "11") setup_golang ;;
        "12") setup_nvm ;;
        "13") setup_pgsql ;;
        "14") setup_freeswitch ;;
        "15") uninstall_freeswitch ;;
        "16") setup_python_dev ;;
        "17") setup_audio_tools ;;
        "18") setup_all ;;
        "19") toggle_swsh ;;
        "20") show_status ;;
        "21") clean_environment ;;
    esac
done
