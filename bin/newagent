#!/bin/bash
# newagent - Create a new SignalWire agent project with full structure
# Usage: newagent <project_name>

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

print_step() {
    echo -e "${BLUE}==>${NC} $1"
}

print_success() {
    echo -e "${GREEN}✓${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}!${NC} $1"
}

print_error() {
    echo -e "${RED}✗${NC} $1"
}

usage() {
    echo "Usage: newagent <project_name>"
    echo ""
    echo "Creates a new SignalWire agent project with:"
    echo "  - Full directory structure (agents/, skills/, tests/, web/)"
    echo "  - Main agent using AgentBase with tool decorators"
    echo "  - Entry point with environment loading"
    echo "  - Test scaffolding with pytest"
    echo "  - Pre-configured .env with SignalWire credentials"
    echo "  - Python virtual environment"
    echo ""
    echo "Example:"
    echo "  newagent mybot"
    echo "  cd /workdir/mybot"
    echo "  up"
    exit 1
}

# Check for project name
if [ -z "$1" ]; then
    usage
fi

NAME="$1"
PROJECT_DIR="/workdir/$NAME"

# Check if directory exists
if [ -d "$PROJECT_DIR" ]; then
    print_warning "Directory $PROJECT_DIR already exists"
    read -p "Overwrite? (y/n): " confirm
    if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
        echo "Aborted."
        exit 0
    fi
    rm -rf "$PROJECT_DIR"
fi

print_step "Creating SignalWire agent project: $NAME"

# Create directory structure
mkdir -p "$PROJECT_DIR"/{agents,skills,tests,web}
cd "$PROJECT_DIR"

# Get credentials from environment or /workdir/.env
if [ -f /workdir/.env ]; then
    source /workdir/.env 2>/dev/null || true
fi

# Standard variable names
SW_SPACE="${SIGNALWIRE_SPACE_NAME:-}"
SW_PROJECT="${SIGNALWIRE_PROJECT_ID:-}"
SW_TOKEN="${SIGNALWIRE_TOKEN:-}"
NGROK_URL="${NGROK_URL:-}"

# Try to get ngrok URL if not set
if [ -z "$NGROK_URL" ]; then
    NGROK_URL=$(curl -s http://127.0.0.1:4040/api/tunnels 2>/dev/null | jq -r '.tunnels[0].public_url // empty' 2>/dev/null || true)
fi

# Generate random password for basic auth
BASIC_AUTH_PASS=$(openssl rand -base64 32 | tr -d '/+=' | head -c 32)

print_step "Creating project files..."

# Create agents/__init__.py
cat > agents/__init__.py << 'EOF'
from .main_agent import MainAgent

__all__ = ["MainAgent"]
EOF
print_success "agents/__init__.py"

# Create main agent module
cat > agents/main_agent.py << 'EOF'
#!/usr/bin/env python3
"""Main Agent - SignalWire AI Agent"""

import os
from signalwire_agents import AgentBase, SwaigFunctionResult


class MainAgent(AgentBase):
    """Main voice AI agent."""

    def __init__(self):
        super().__init__(
            name="main-agent",
            route="/swml"
        )

        # Set basic auth if configured
        user = os.getenv("SWML_BASIC_AUTH_USER")
        password = os.getenv("SWML_BASIC_AUTH_PASSWORD")
        if user and password:
            self.set_params({
                "swml_basic_auth_user": user,
                "swml_basic_auth_password": password,
            })

        self._configure_voice()
        self._configure_prompts()
        self._configure_debug_webhooks()

    def _configure_voice(self):
        """Set up voice and language."""
        self.add_language("English", "en-US", "rime.spore")

        self.set_params({
            "end_of_speech_timeout": 500,
            "attention_timeout": 15000,
        })

    def _configure_prompts(self):
        """Set up AI prompts."""
        self.prompt_add_section(
            "Role",
            "You are a helpful AI assistant. "
            "Help callers with their questions and requests."
        )

        self.prompt_add_section(
            "Guidelines",
            body="Follow these guidelines:",
            bullets=[
                "Be professional and courteous",
                "Ask clarifying questions when needed",
                "Keep responses concise and helpful",
                "If you cannot help, offer to transfer to a human"
            ]
        )

    @AgentBase.tool(
        name="get_info",
        description="Get information about a topic",
        parameters={
            "type": "object",
            "properties": {
                "topic": {
                    "type": "string",
                    "description": "The topic to get information about"
                }
            },
            "required": ["topic"]
        }
    )
    def get_info(self, args, raw_data):
        """Get information about a topic."""
        topic = args.get("topic", "")
        # TODO: Implement your logic here
        return SwaigFunctionResult(f"Information about {topic}: This is a placeholder response.")

    def _configure_debug_webhooks(self):
        """Set up debug and post-prompt webhooks."""
        proxy_url = os.getenv("SWML_PROXY_URL_BASE", "")
        debug_level = int(os.getenv("DEBUG_WEBHOOK_LEVEL", "1"))
        auth_user = os.getenv("SWML_BASIC_AUTH_USER", "")
        auth_pass = os.getenv("SWML_BASIC_AUTH_PASSWORD", "")

        if proxy_url and debug_level > 0:
            # Build URL with basic auth credentials
            if auth_user and auth_pass:
                # Insert credentials into URL: https://user:pass@host/path
                if "://" in proxy_url:
                    scheme, rest = proxy_url.split("://", 1)
                    auth_proxy_url = f"{scheme}://{auth_user}:{auth_pass}@{rest}"
                else:
                    auth_proxy_url = f"{auth_user}:{auth_pass}@{proxy_url}"
            else:
                auth_proxy_url = proxy_url

            self.set_params({
                "debug_webhook_url": f"{auth_proxy_url}/debug",
                "debug_webhook_level": debug_level,
            })
            self.set_post_prompt(
                "Summarize the conversation including: "
                "the caller's main request, any actions taken, "
                "and the outcome of the call."
            )
            self.set_post_prompt_url(f"{auth_proxy_url}/post_prompt")

    def on_summary(self, summary):
        """Handle call summary."""
        print(f"Call summary: {summary}")
EOF
print_success "agents/main_agent.py"

# Create skills/__init__.py
cat > skills/__init__.py << 'EOF'
"""Skills module - Add reusable agent skills here."""
EOF
print_success "skills/__init__.py"

# Create app.py entry point
cat > app.py << 'EOF'
#!/usr/bin/env python3
"""Main entry point for the agent server."""

import os
import sys
import json
from pathlib import Path
from datetime import datetime
from dotenv import load_dotenv
from starlette.requests import Request
import requests

# Load environment variables from .env file
load_dotenv()

from signalwire_agents import AgentServer
from agents import MainAgent

# ANSI colors for console output
RESET = "\033[0m"
BOLD = "\033[1m"
DIM = "\033[2m"
CYAN = "\033[36m"
GREEN = "\033[32m"
YELLOW = "\033[33m"
MAGENTA = "\033[35m"
BLUE = "\033[34m"
WHITE = "\033[37m"


def print_separator(char="─", width=80):
    print(f"{DIM}{char * width}{RESET}")


def print_debug_data(data):
    """Pretty print debug webhook data."""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print()
    print_separator("═")
    print(f"{BOLD}{CYAN}▶ DEBUG WEBHOOK{RESET}")
    print(f"{DIM}{timestamp}{RESET}")
    print_separator()

    # Extract and display key fields
    if isinstance(data, dict):
        event_type = data.get("event_type", data.get("type", "unknown"))
        print(f"{YELLOW}Event:{RESET} {event_type}")

        # Show call info if present
        call_id = data.get("call_id", data.get("CallSid", ""))
        if call_id:
            print(f"{YELLOW}Call ID:{RESET} {call_id}")

        # Show conversation data if present
        if "conversation" in data:
            print(f"\n{BOLD}{YELLOW}Conversation:{RESET}")
            for msg in data.get("conversation", [])[-5:]:  # Last 5 messages
                role = msg.get("role", "?")
                content = msg.get("content", "")[:100]
                color = GREEN if role == "assistant" else MAGENTA
                print(f"  {color}{role}:{RESET} {content}")

        # Show full data in verbose mode
        debug_level = int(os.getenv("DEBUG_WEBHOOK_LEVEL", "1"))
        if debug_level >= 2:
            print(f"\n{BOLD}{YELLOW}Full Data:{RESET}")
            formatted = json.dumps(data, indent=2)
            for line in formatted.split('\n')[:50]:
                print(f"  {DIM}{line}{RESET}")
    else:
        print(f"{DIM}{data}{RESET}")

    print_separator("═")
    print()
    sys.stdout.flush()


def print_post_prompt_data(data):
    """Pretty print post-prompt summary data."""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print()
    print_separator("═")
    print(f"{BOLD}{YELLOW}▶ POST-PROMPT SUMMARY{RESET}")
    print(f"{DIM}{timestamp}{RESET}")
    print_separator()

    if isinstance(data, dict):
        # Show summary if present
        summary = data.get("post_prompt_data", {})
        if isinstance(summary, dict):
            for key, value in summary.items():
                print(f"{GREEN}{key}:{RESET} {value}")
        elif summary:
            print(f"{GREEN}Summary:{RESET} {summary}")

        # Show raw response if present
        raw = data.get("raw_response", data.get("response", ""))
        if raw:
            print(f"\n{BOLD}{YELLOW}Response:{RESET}")
            print(f"  {MAGENTA}{raw}{RESET}")

        # Show call info
        call_id = data.get("call_id", "")
        if call_id:
            print(f"\n{DIM}Call ID: {call_id}{RESET}")
    else:
        print(f"{DIM}{data}{RESET}")

    print_separator("═")
    print()
    sys.stdout.flush()


def main():
    host = os.getenv("HOST", "0.0.0.0")
    port = int(os.getenv("PORT", "5000"))
    proxy_url = os.getenv("SWML_PROXY_URL_BASE", "")
    debug_level = int(os.getenv("DEBUG_WEBHOOK_LEVEL", "1"))

    # Create server and register agent
    server = AgentServer(host=host, port=port)
    server.register(MainAgent())

    # Serve static files from web/ directory at /
    web_dir = Path(__file__).parent / "web"
    if web_dir.exists():
        server.serve_static_files(str(web_dir))

    # Add debug webhook endpoint
    @server.app.post('/debug')
    async def debug_webhook(request: Request):
        """Receive and display debug webhook data."""
        try:
            data = await request.json()
        except:
            body = await request.body()
            data = body.decode('utf-8', errors='ignore')
        print_debug_data(data)
        return {'status': 'received'}

    # Add post-prompt webhook endpoint
    @server.app.post('/post_prompt')
    async def post_prompt_webhook(request: Request):
        """Receive and display post-prompt summary data."""
        try:
            data = await request.json()
        except:
            body = await request.body()
            data = body.decode('utf-8', errors='ignore')
        print_post_prompt_data(data)
        return {'status': 'received'}

    # Store the SWML handler info for reuse
    swml_handler_info = {"id": None, "address_id": None, "address": None}

    def get_signalwire_host():
        """Get the full SignalWire host from space name."""
        space = os.getenv("SIGNALWIRE_SPACE_NAME", "")
        if not space:
            return None
        # If it's already a full domain, use it as-is
        if "." in space:
            return space
        # Otherwise append .signalwire.com
        return f"{space}.signalwire.com"

    def setup_swml_handler():
        """Set up SWML handler on startup."""
        sw_host = get_signalwire_host()
        project = os.getenv("SIGNALWIRE_PROJECT_ID", "")
        token = os.getenv("SIGNALWIRE_TOKEN", "")
        agent_name = os.getenv("AGENT_NAME", "agent")
        auth_user = os.getenv("SWML_BASIC_AUTH_USER", "")
        auth_pass = os.getenv("SWML_BASIC_AUTH_PASSWORD", "")

        if not all([sw_host, project, token]):
            print(f"{YELLOW}SignalWire credentials not configured - skipping SWML handler setup{RESET}")
            return

        if not proxy_url:
            print(f"{YELLOW}SWML_PROXY_URL_BASE not set - skipping SWML handler setup{RESET}")
            return

        # Build SWML URL with basic auth credentials
        if auth_user and auth_pass and "://" in proxy_url:
            scheme, rest = proxy_url.split("://", 1)
            swml_url = f"{scheme}://{auth_user}:{auth_pass}@{rest}/swml"
        else:
            swml_url = proxy_url + "/swml"

        auth = (project, token)
        headers = {"Content-Type": "application/json", "Accept": "application/json"}

        # Look for an existing handler by name
        existing = find_existing_handler(sw_host, auth, agent_name)
        if existing:
            swml_handler_info["id"] = existing["id"]
            swml_handler_info["address_id"] = existing["address_id"]
            swml_handler_info["address"] = existing["address"]

            # Check if the URL needs updating
            if existing.get("url") != swml_url:
                try:
                    update_resp = requests.put(
                        f"https://{sw_host}/api/fabric/resources/external_swml_handlers/{existing['id']}",
                        json={
                            "primary_request_url": swml_url,
                            "primary_request_method": "POST"
                        },
                        auth=auth,
                        headers=headers
                    )
                    update_resp.raise_for_status()
                    print(f"{GREEN}Updated SWML handler:{RESET} {existing['name']}")
                    print(f"{GREEN}New URL:{RESET} {swml_url}")
                except Exception as e:
                    print(f"{YELLOW}Failed to update handler URL:{RESET} {e}")
            else:
                print(f"{GREEN}Using existing SWML handler:{RESET} {existing['name']}")

            print(f"{GREEN}Call address:{RESET} {existing['address']}")
        else:
            # Create a new external SWML handler with the agent name
            try:
                handler_resp = requests.post(
                    f"https://{sw_host}/api/fabric/resources/external_swml_handlers",
                    json={
                        "name": agent_name,
                        "used_for": "calling",
                        "primary_request_url": swml_url,
                        "primary_request_method": "POST"
                    },
                    auth=auth,
                    headers=headers
                )
                handler_resp.raise_for_status()
                handler_id = handler_resp.json().get("id")
                swml_handler_info["id"] = handler_id

                # Get the address for this handler
                addr_resp = requests.get(
                    f"https://{sw_host}/api/fabric/resources/external_swml_handlers/{handler_id}/addresses",
                    auth=auth,
                    headers={"Accept": "application/json"}
                )
                addr_resp.raise_for_status()
                addresses = addr_resp.json().get("data", [])
                if addresses:
                    swml_handler_info["address_id"] = addresses[0]["id"]
                    swml_handler_info["address"] = addresses[0]["channels"]["audio"]
                    print(f"{GREEN}Created SWML handler:{RESET} {agent_name}")
                    print(f"{GREEN}Call address:{RESET} {swml_handler_info['address']}")
                else:
                    print(f"{YELLOW}No address found for handler{RESET}")
            except Exception as e:
                print(f"{YELLOW}Failed to create SWML handler:{RESET} {e}")

    def find_existing_handler(sw_host, auth, agent_name):
        """Find an existing SWML handler by name."""
        try:
            # List all external SWML handlers
            resp = requests.get(
                f"https://{sw_host}/api/fabric/resources/external_swml_handlers",
                auth=auth,
                headers={"Accept": "application/json"}
            )
            if resp.status_code != 200:
                print(f"{YELLOW}Failed to list handlers:{RESET} {resp.status_code}")
                return None

            handlers = resp.json().get("data", [])

            for handler in handlers:
                # The name is nested in swml_webhook object
                swml_webhook = handler.get("swml_webhook", {})
                handler_name = swml_webhook.get("name") or handler.get("display_name")

                # Check if this handler matches our agent name
                if handler_name == agent_name:
                    handler_id = handler.get("id")
                    handler_url = swml_webhook.get("primary_request_url", "")
                    # Get the address for this handler
                    addr_resp = requests.get(
                        f"https://{sw_host}/api/fabric/resources/external_swml_handlers/{handler_id}/addresses",
                        auth=auth,
                        headers={"Accept": "application/json"}
                    )
                    if addr_resp.status_code == 200:
                        addresses = addr_resp.json().get("data", [])
                        if addresses:
                            return {
                                "id": handler_id,
                                "name": handler_name,
                                "url": handler_url,
                                "address_id": addresses[0]["id"],
                                "address": addresses[0]["channels"]["audio"]
                            }
        except Exception as e:
            print(f"{YELLOW}Error checking existing handlers:{RESET} {e}")
        return None

    @server.app.get('/get_token')
    def get_token():
        """Get a guest token for the web client to call the agent."""
        from starlette.responses import JSONResponse

        sw_host = get_signalwire_host()
        project = os.getenv("SIGNALWIRE_PROJECT_ID", "")
        token = os.getenv("SIGNALWIRE_TOKEN", "")

        if not all([sw_host, project, token]):
            return JSONResponse({"error": "SignalWire credentials not configured"}, status_code=500)

        if not swml_handler_info["address_id"]:
            return JSONResponse({"error": "SWML handler not configured - check startup logs"}, status_code=500)

        auth = (project, token)
        headers = {"Content-Type": "application/json", "Accept": "application/json"}

        try:
            # Create a guest token with access to this address
            import time
            expire_at = int(time.time()) + 3600 * 24  # 24 hours

            guest_resp = requests.post(
                f"https://{sw_host}/api/fabric/guests/tokens",
                json={
                    "allowed_addresses": [swml_handler_info["address_id"]],
                    "expire_at": expire_at
                },
                auth=auth,
                headers=headers
            )
            guest_resp.raise_for_status()
            guest_token = guest_resp.json().get("token", "")

            return {
                "token": guest_token,
                "address": swml_handler_info["address"]
            }

        except requests.exceptions.RequestException as e:
            print(f"{YELLOW}Token request failed:{RESET} {e}")
            if hasattr(e, 'response') and e.response is not None:
                print(f"{YELLOW}Response:{RESET} {e.response.text}")
            return JSONResponse({"error": str(e)}, status_code=500)

    @server.app.get('/get_credentials')
    def get_credentials():
        """Get basic auth credentials for the web UI."""
        return {
            "user": os.getenv("SWML_BASIC_AUTH_USER", ""),
            "password": os.getenv("SWML_BASIC_AUTH_PASSWORD", "")
        }

    # Set up SWML handler on startup
    setup_swml_handler()

    # Print startup banner
    print()
    print_separator("═")
    print(f"{BOLD}{CYAN}SignalWire Agents SDK Server{RESET}")
    print_separator()
    print(f"{GREEN}SWML endpoint:{RESET}  http://{host}:{port}/swml")
    print(f"{GREEN}SWAIG endpoint:{RESET} http://{host}:{port}/swml/swaig/")
    print(f"{GREEN}Web root:{RESET}       http://{host}:{port}/")
    print(f"{GREEN}Get token:{RESET}      http://{host}:{port}/get_token")
    print(f"{GREEN}Debug webhook:{RESET}  http://{host}:{port}/debug")
    print(f"{GREEN}Post-prompt:{RESET}    http://{host}:{port}/post_prompt")

    if proxy_url:
        print()
        print(f"{BOLD}{YELLOW}Public URLs:{RESET}")
        print(f"  SWML:        {proxy_url}/swml")
        print(f"  SWAIG:       {proxy_url}/swml/swaig/")
        print(f"  Get token:   {proxy_url}/get_token")
        print(f"  Debug:       {proxy_url}/debug")
        print(f"  Post-prompt: {proxy_url}/post_prompt")

    if swml_handler_info["address"]:
        print()
        print(f"{BOLD}{YELLOW}WebRTC Call Address:{RESET}")
        print(f"  {swml_handler_info['address']}")

    print()
    print(f"{DIM}Debug level: {debug_level} (0=off, 1=basic, 2=verbose){RESET}")
    print_separator("═")
    print()

    server.run()


if __name__ == "__main__":
    main()
EOF
print_success "app.py"

# Create tests/__init__.py
cat > tests/__init__.py << 'EOF'
"""Test package."""
EOF

# Create tests/test_agent.py
cat > tests/test_agent.py << 'EOF'
#!/usr/bin/env python3
"""
Tests for the main agent using swaig-test.

This test suite verifies:
- Agent can be loaded without errors
- SWML structure is valid
- SWAIG functions are defined correctly
- SWAIG functions execute and return expected results
"""

import subprocess
import json
import sys
from pathlib import Path

import pytest


# Path to the main agent file
AGENT_FILE = Path(__file__).parent.parent / "agents" / "main_agent.py"


def run_swaig_test(*args) -> tuple[int, str, str]:
    """Run swaig-test on the agent and return (returncode, stdout, stderr)."""
    cmd = [sys.executable, "-m", "signalwire_agents.cli.swaig_test_wrapper", str(AGENT_FILE)] + list(args)
    result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
    return result.returncode, result.stdout, result.stderr


def get_swml_json() -> dict:
    """Get SWML JSON output from the agent."""
    returncode, stdout, stderr = run_swaig_test("--dump-swml", "--raw")
    if returncode != 0:
        pytest.fail(f"swaig-test failed:\nstderr: {stderr}\nstdout: {stdout}")
    try:
        return json.loads(stdout)
    except json.JSONDecodeError as e:
        pytest.fail(f"Invalid JSON: {e}\nOutput: {stdout}")


def list_tools() -> list[str]:
    """List tools available in the agent."""
    returncode, stdout, stderr = run_swaig_test("--list-tools")
    if returncode != 0:
        return []
    tools = []
    for line in stdout.split('\n'):
        line = line.strip()
        if ' - ' in line and not line.startswith('Parameters:'):
            parts = line.split(' - ')
            if parts:
                tool_name = parts[0].strip()
                if tool_name and not tool_name.startswith('('):
                    tools.append(tool_name)
    return tools


class TestAgentLoading:
    """Test that the agent can be loaded without errors."""

    def test_agent_loads(self):
        """Test agent file can be loaded by swaig-test."""
        returncode, stdout, stderr = run_swaig_test("--list-tools")
        assert returncode == 0, f"Failed to load agent: {stderr}"

    def test_agent_has_tools(self):
        """Test agent has expected tools defined."""
        tools = list_tools()
        assert "get_info" in tools, f"Missing get_info tool. Found: {tools}"


class TestSWMLGeneration:
    """Test that the agent generates valid SWML documents."""

    def test_swml_structure(self):
        """Test SWML has required structure."""
        swml = get_swml_json()
        assert "version" in swml, "SWML missing 'version'"
        assert "sections" in swml, "SWML missing 'sections'"
        assert "main" in swml["sections"], "SWML missing 'sections.main'"

    def test_swml_has_ai_section(self):
        """Test SWML has AI configuration."""
        swml = get_swml_json()
        main_section = swml.get("sections", {}).get("main", [])
        ai_found = any("ai" in verb for verb in main_section)
        assert ai_found, "SWML missing 'ai' verb"

    def test_swml_has_swaig_functions(self):
        """Test SWML includes SWAIG function definitions."""
        swml = get_swml_json()
        main_section = swml.get("sections", {}).get("main", [])
        for verb in main_section:
            if "ai" in verb:
                ai_config = verb["ai"]
                assert "SWAIG" in ai_config, "AI config missing SWAIG section"
                assert "functions" in ai_config["SWAIG"], "SWAIG missing functions"
                return
        pytest.fail("No AI verb found in SWML")


class TestFunctionExecution:
    """Test that SWAIG functions can be executed."""

    def test_get_info_function(self):
        """Test get_info function executes successfully."""
        returncode, stdout, stderr = run_swaig_test(
            "--exec", "get_info", "--topic", "SignalWire"
        )
        assert returncode == 0, f"Function execution failed: {stderr}"
        assert "SignalWire" in stdout, f"Expected 'SignalWire' in output: {stdout}"

    def test_get_info_with_different_topic(self):
        """Test get_info function with different topic."""
        returncode, stdout, stderr = run_swaig_test(
            "--exec", "get_info", "--topic", "testing"
        )
        assert returncode == 0, f"Function execution failed: {stderr}"
        assert "testing" in stdout.lower(), f"Expected 'testing' in output: {stdout}"


class TestDirectImport:
    """Test direct Python import of the agent."""

    def test_agent_creation(self):
        """Test that agent can be instantiated."""
        from agents import MainAgent
        agent = MainAgent()
        assert agent is not None
        assert agent.name == "main-agent"

    def test_get_info_tool_direct(self):
        """Test the get_info tool via direct call."""
        from agents import MainAgent
        agent = MainAgent()
        result = agent.get_info({"topic": "test"}, {})
        assert "test" in result.response


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
EOF
print_success "tests/test_agent.py"

# Create .env file with credentials
cat > .env << ENVEOF
# SignalWire Credentials
SIGNALWIRE_SPACE_NAME=${SW_SPACE}
SIGNALWIRE_PROJECT_ID=${SW_PROJECT}
SIGNALWIRE_TOKEN=${SW_TOKEN}

# Agent Server Configuration
HOST=0.0.0.0
PORT=5000

# Agent name (used for SWML handler - keeps the same handler across restarts)
AGENT_NAME=${NAME}

# Basic Auth for SWML webhooks
SWML_BASIC_AUTH_USER=signalwire
SWML_BASIC_AUTH_PASSWORD=${BASIC_AUTH_PASS}

# Public URL (ngrok tunnel)
SWML_PROXY_URL_BASE=${NGROK_URL}

# Debug settings (0=off, 1=basic, 2=verbose)
DEBUG_WEBHOOK_LEVEL=1
ENVEOF
print_success ".env"

# Create .env.example (without secrets)
cat > .env.example << 'EOF'
# SignalWire Credentials
SIGNALWIRE_SPACE_NAME=your-space
SIGNALWIRE_PROJECT_ID=your-project-id
SIGNALWIRE_TOKEN=your-api-token

# Agent Server Configuration
HOST=0.0.0.0
PORT=5000

# Agent name (used for SWML handler - keeps the same handler across restarts)
AGENT_NAME=myagent

# Basic Auth for SWML webhooks
SWML_BASIC_AUTH_USER=signalwire
SWML_BASIC_AUTH_PASSWORD=your-secure-password

# Public URL (ngrok tunnel or production domain)
SWML_PROXY_URL_BASE=https://your-domain.ngrok.io

# Debug settings (0=off, 1=basic, 2=verbose)
DEBUG_WEBHOOK_LEVEL=1
EOF
print_success ".env.example"

# Create .gitignore
cat > .gitignore << 'EOF'
# Environment
.env
.venv/
venv/
__pycache__/
*.pyc
*.pyo

# IDE
.vscode/
.idea/
*.swp
*.swo

# Testing
.pytest_cache/
.coverage
htmlcov/

# Build
dist/
build/
*.egg-info/

# Logs
*.log

# OS
.DS_Store
Thumbs.db
EOF
print_success ".gitignore"

# Create requirements.txt
cat > requirements.txt << 'EOF'
signalwire-agents>=2.0.0
flask>=2.0.0
python-dotenv>=1.0.0
requests>=2.28.0
pytest>=7.0.0
EOF
print_success "requirements.txt"

# Create README.md
cat > README.md << READMEEOF
# ${NAME}

A SignalWire AI Agent built with signalwire-agents.

## Quick Start

\`\`\`bash
# Activate the virtual environment (auto-activates in WireStarter)
cd /workdir/${NAME}

# Run the agent
up

# Or run directly
python app.py
\`\`\`

## Endpoints

| Endpoint | Method | Description |
|----------|--------|-------------|
| \`/swml\` | POST | Main SWML endpoint - point your SignalWire phone number here |
| \`/debug\` | POST | Debug webhook - receives real-time call data |
| \`/post_prompt\` | POST | Post-prompt webhook - receives call summaries |
| \`/\` | GET | Static files from \`web/\` directory |

### Testing Endpoints

\`\`\`bash
# Get SWML configuration
curl -X POST http://localhost:5000/swml \\
  -H "Content-Type: application/json" \\
  -d '{}'

# Test debug webhook
curl -X POST http://localhost:5000/debug \\
  -H "Content-Type: application/json" \\
  -d '{"event_type": "test", "call_id": "test-123"}'

# Test post-prompt webhook
curl -X POST http://localhost:5000/post_prompt \\
  -H "Content-Type: application/json" \\
  -d '{"post_prompt_data": {"summary": "Test call"}}'

# With ngrok (replace with your URL)
curl -X POST \${NGROK_URL}/swml \\
  -H "Content-Type: application/json" \\
  -d '{}'
\`\`\`

## Project Structure

\`\`\`
${NAME}/
├── agents/
│   ├── __init__.py
│   └── main_agent.py    # Main agent implementation
├── skills/
│   └── __init__.py      # Reusable skills
├── tests/
│   └── test_agent.py    # Test suite
├── web/
│   └── index.html       # Static files & documentation
├── app.py               # Entry point (run with 'up')
├── .env                 # Environment configuration
└── requirements.txt     # Python dependencies
\`\`\`

## Configuration

Edit \`.env\` to configure:

| Variable | Description |
|----------|-------------|
| \`SIGNALWIRE_SPACE_NAME\` | Your SignalWire space name |
| \`SIGNALWIRE_PROJECT_ID\` | Your SignalWire project ID |
| \`SIGNALWIRE_TOKEN\` | Your SignalWire API token |
| \`HOST\` | Server host (default: 0.0.0.0) |
| \`PORT\` | Server port (default: 5000) |
| \`SWML_BASIC_AUTH_USER\` | Basic auth username |
| \`SWML_BASIC_AUTH_PASSWORD\` | Basic auth password |
| \`SWML_PROXY_URL_BASE\` | Public URL (ngrok URL) |
| \`DEBUG_WEBHOOK_LEVEL\` | Debug verbosity: 0=off, 1=basic, 2=verbose |

## Debug Webhooks

This agent includes built-in debug webhook support:

- **Level 0**: Disabled - no debug output
- **Level 1**: Basic - event types, call IDs, conversation snippets
- **Level 2**: Verbose - full JSON data for each event

Debug data and post-prompt summaries are pretty-printed to the console in real-time.

## Adding Tools

Add new tools to your agent using the \`@AgentBase.tool\` decorator:

\`\`\`python
@AgentBase.tool(
    name="my_tool",
    description="What this tool does",
    parameters={
        "type": "object",
        "properties": {
            "param1": {"type": "string", "description": "Parameter description"}
        },
        "required": ["param1"]
    }
)
def my_tool(self, args, raw_data):
    param1 = args.get("param1")
    return SwaigFunctionResult(f"Result: {param1}")
\`\`\`

## Testing

\`\`\`bash
# Run unit tests
pytest tests/ -v

# Test endpoints are reachable
testapp
\`\`\`

## Useful Commands

\`\`\`bash
up            # Run agent (auto-restarts on crash)
urls          # Show ngrok tunnel URLs
testapp       # Test local and public endpoints
webhook       # Start standalone webhook catcher
\`\`\`

## Connecting to SignalWire

1. Run \`urls\` to get your public ngrok URL
2. In SignalWire Dashboard, go to Phone Numbers
3. Set the "Handle Calls Using" to "a]SWML Script"
4. Set the SWML URL to: \`https://your-ngrok-url/swml\`
5. Save and make a test call!
READMEEOF
print_success "README.md"

# Create sample static file with endpoint documentation
cat > web/index.html << 'HTMLEOF'
<!DOCTYPE html>
<html>
<head>
    <title>SignalWire Agents SDK</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: system-ui, -apple-system, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 40px 20px;
            background: #f8f9fa;
            color: #333;
        }
        h1 {
            color: #044cf6;
            border-bottom: 3px solid #044cf6;
            padding-bottom: 10px;
        }
        h2 {
            color: #333;
            margin-top: 40px;
            border-bottom: 1px solid #ddd;
            padding-bottom: 8px;
        }
        .status {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .call-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            padding: 30px;
            margin: 20px 0;
            color: white;
            text-align: center;
        }
        .call-section h2 {
            color: white;
            border: none;
            margin-top: 0;
        }
        .call-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }
        .call-btn {
            padding: 15px 40px;
            font-size: 18px;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .call-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .call-btn.connect {
            background: #10b981;
            color: white;
        }
        .call-btn.connect:hover:not(:disabled) {
            background: #059669;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(16, 185, 129, 0.4);
        }
        .call-btn.disconnect {
            background: #ef4444;
            color: white;
        }
        .call-btn.disconnect:hover:not(:disabled) {
            background: #dc2626;
        }
        .call-status {
            margin-top: 15px;
            font-size: 14px;
            opacity: 0.9;
        }
        .destination-input {
            padding: 12px 15px;
            font-size: 14px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            background: rgba(255,255,255,0.1);
            color: white;
            width: 250px;
        }
        .destination-input::placeholder {
            color: rgba(255,255,255,0.6);
        }
        .destination-input:focus {
            outline: none;
            border-color: rgba(255,255,255,0.6);
            background: rgba(255,255,255,0.2);
        }
        .endpoint {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
        }
        .endpoint h3 {
            margin-top: 0;
            color: #044cf6;
        }
        .method {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 12px;
            margin-right: 10px;
        }
        .method.get { background: #61affe; color: white; }
        .method.post { background: #49cc90; color: white; }
        .path {
            font-family: monospace;
            font-size: 16px;
            color: #333;
        }
        code, pre {
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
        }
        code {
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 14px;
        }
        pre {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            font-size: 13px;
            line-height: 1.5;
            margin: 0;
        }
        pre .comment { color: #6a9955; }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        th, td {
            text-align: left;
            padding: 12px;
            border-bottom: 1px solid #ddd;
        }
        th { background: #f1f3f4; }
        .footer {
            margin-top: 50px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            color: #666;
            font-size: 14px;
        }
        /* Tabs */
        .tabs {
            display: flex;
            gap: 0;
            margin-top: 15px;
        }
        .tab {
            padding: 8px 16px;
            background: #e9ecef;
            border: 1px solid #ddd;
            border-bottom: none;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            color: #666;
            transition: all 0.2s;
        }
        .tab:hover { background: #dee2e6; }
        .tab.active {
            background: #1e1e1e;
            color: #d4d4d4;
            border-color: #1e1e1e;
        }
        .tab-content {
            display: none;
            border-radius: 0 8px 8px 8px;
        }
        .tab-content.active { display: block; }
        /* Browser tab */
        .browser-panel {
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 0 8px 8px 8px;
            padding: 15px;
        }
        .try-btn {
            padding: 10px 20px;
            background: #044cf6;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            font-size: 14px;
            transition: all 0.2s;
        }
        .try-btn:hover { background: #0339c2; }
        .try-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .response-area {
            margin-top: 15px;
            display: none;
        }
        .response-area.visible { display: block; }
        .response-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        .response-status {
            font-size: 13px;
            font-weight: 500;
        }
        .response-status.success { color: #10b981; }
        .response-status.error { color: #ef4444; }
        .response-time {
            font-size: 12px;
            color: #666;
        }
        .response-body {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 15px;
            border-radius: 8px;
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 12px;
            max-height: 300px;
            overflow: auto;
            white-space: pre-wrap;
            word-break: break-word;
        }
        /* Curl tab */
        .curl-panel {
            position: relative;
        }
        .copy-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            background: rgba(255,255,255,0.1);
            color: #999;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }
        .copy-btn:hover {
            background: rgba(255,255,255,0.2);
            color: #fff;
        }
        /* Audio settings */
        .audio-settings {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        .audio-setting {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: rgba(255,255,255,0.9);
        }
        .audio-setting input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        .audio-setting label {
            cursor: pointer;
        }
    </style>
</head>
<body>
    <h1>SignalWire Agents SDK</h1>

    <div class="status">
        Your agent is running and ready to receive calls!
    </div>

    <div class="call-section">
        <h2>Call Your Agent</h2>
        <p>Test your agent directly from the browser using WebRTC.</p>
        <div class="call-controls">
            <input type="text" id="destination" class="destination-input" placeholder="Address will be auto-filled" />
            <button id="connectBtn" class="call-btn connect">Call Agent</button>
            <button id="disconnectBtn" class="call-btn disconnect" disabled>Hang Up</button>
        </div>
        <div class="audio-settings">
            <div class="audio-setting">
                <input type="checkbox" id="echoCancellation" checked>
                <label for="echoCancellation">Echo Cancellation</label>
            </div>
            <div class="audio-setting">
                <input type="checkbox" id="noiseSuppression">
                <label for="noiseSuppression">Noise Suppression</label>
            </div>
            <div class="audio-setting">
                <input type="checkbox" id="autoGainControl">
                <label for="autoGainControl">Auto Gain Control</label>
            </div>
        </div>
        <div id="callStatus" class="call-status"></div>
    </div>

    <h2>Endpoints</h2>

    <div class="endpoint">
        <h3><span class="method post">POST</span> <span class="path">/swml</span></h3>
        <p>Main SWML endpoint for SignalWire to fetch agent configuration. Point your SignalWire phone number here.</p>
        <div class="tabs">
            <div class="tab active" onclick="switchTab(this, 'swml-browser')">Browser</div>
            <div class="tab" onclick="switchTab(this, 'swml-curl')">curl</div>
        </div>
        <div id="swml-browser" class="tab-content active">
            <div class="browser-panel">
                <button class="try-btn" onclick="tryEndpoint('POST', '/swml', {}, 'swml-response', true)">Try it</button>
                <div id="swml-response" class="response-area"></div>
            </div>
        </div>
        <div id="swml-curl" class="tab-content">
            <div class="curl-panel">
                <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                <pre><span class="comment"># Get the SWML configuration</span>
curl -X POST <span class="base-url"></span>/swml \
  -u <span class="auth-creds"></span> \
  -H "Content-Type: application/json" \
  -d '{}'</pre>
            </div>
        </div>
    </div>

    <div class="endpoint">
        <h3><span class="method post">POST</span> <span class="path">/debug</span></h3>
        <p>Debug webhook endpoint. Receives real-time debug data during calls and displays it in the console.</p>
        <div class="tabs">
            <div class="tab active" onclick="switchTab(this, 'debug-browser')">Browser</div>
            <div class="tab" onclick="switchTab(this, 'debug-curl')">curl</div>
        </div>
        <div id="debug-browser" class="tab-content active">
            <div class="browser-panel">
                <button class="try-btn" onclick="tryEndpoint('POST', '/debug', {event_type: 'test', call_id: 'test-123'}, 'debug-response', true)">Try it</button>
                <div id="debug-response" class="response-area"></div>
            </div>
        </div>
        <div id="debug-curl" class="tab-content">
            <div class="curl-panel">
                <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                <pre><span class="comment"># Simulate a debug webhook</span>
curl -X POST <span class="base-url"></span>/debug \
  -u <span class="auth-creds"></span> \
  -H "Content-Type: application/json" \
  -d '{"event_type": "test", "call_id": "test-123"}'</pre>
            </div>
        </div>
    </div>

    <div class="endpoint">
        <h3><span class="method post">POST</span> <span class="path">/post_prompt</span></h3>
        <p>Post-prompt webhook endpoint. Receives call summary data when calls end.</p>
        <div class="tabs">
            <div class="tab active" onclick="switchTab(this, 'postprompt-browser')">Browser</div>
            <div class="tab" onclick="switchTab(this, 'postprompt-curl')">curl</div>
        </div>
        <div id="postprompt-browser" class="tab-content active">
            <div class="browser-panel">
                <button class="try-btn" onclick="tryEndpoint('POST', '/post_prompt', {post_prompt_data: {summary: 'Test call completed'}}, 'postprompt-response', true)">Try it</button>
                <div id="postprompt-response" class="response-area"></div>
            </div>
        </div>
        <div id="postprompt-curl" class="tab-content">
            <div class="curl-panel">
                <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                <pre><span class="comment"># Simulate a post-prompt webhook</span>
curl -X POST <span class="base-url"></span>/post_prompt \
  -u <span class="auth-creds"></span> \
  -H "Content-Type: application/json" \
  -d '{"post_prompt_data": {"summary": "Test call completed"}}'</pre>
            </div>
        </div>
    </div>

    <div class="endpoint">
        <h3><span class="method get">GET</span> <span class="path">/get_token</span></h3>
        <p>Get a guest token for WebRTC calls. Creates an external SWML handler and returns a token to call your agent.</p>
        <div class="tabs">
            <div class="tab active" onclick="switchTab(this, 'token-browser')">Browser</div>
            <div class="tab" onclick="switchTab(this, 'token-curl')">curl</div>
        </div>
        <div id="token-browser" class="tab-content active">
            <div class="browser-panel">
                <button class="try-btn" onclick="tryEndpoint('GET', '/get_token', null, 'token-response')">Try it</button>
                <div id="token-response" class="response-area"></div>
            </div>
        </div>
        <div id="token-curl" class="tab-content">
            <div class="curl-panel">
                <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                <pre><span class="comment"># Get a guest token</span>
curl <span class="base-url"></span>/get_token</pre>
            </div>
        </div>
    </div>

    <div class="endpoint">
        <h3><span class="method get">GET</span> <span class="path">/</span></h3>
        <p>Static files. This page and any other files in the <code>web/</code> directory.</p>
    </div>

    <h2>SWAIG Functions</h2>
    <p>Test the agent's SWAIG functions directly.</p>

    <div class="endpoint">
        <h3><span class="method post">POST</span> <span class="path">/swml/swaig/</span> - get_info</h3>
        <p>Get information about a topic. This is a sample SWAIG function you can customize.</p>
        <div class="tabs">
            <div class="tab active" onclick="switchTab(this, 'swaig-browser')">Browser</div>
            <div class="tab" onclick="switchTab(this, 'swaig-curl')">curl</div>
        </div>
        <div id="swaig-browser" class="tab-content active">
            <div class="browser-panel">
                <button class="try-btn" onclick="tryEndpoint('POST', '/swml/swaig/', {function: 'get_info', argument: {parsed: [{topic: 'SignalWire'}]}}, 'swaig-response', true)">Try it</button>
                <div id="swaig-response" class="response-area"></div>
            </div>
        </div>
        <div id="swaig-curl" class="tab-content">
            <div class="curl-panel">
                <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                <pre><span class="comment"># Call the get_info SWAIG function</span>
curl -X POST <span class="base-url"></span>/swml/swaig/ \
  -u <span class="auth-creds"></span> \
  -H "Content-Type: application/json" \
  -d '{"function": "get_info", "argument": {"parsed": [{"topic": "SignalWire"}]}}'</pre>
            </div>
        </div>
    </div>

    <h2>Configuration</h2>
    <table>
        <tr>
            <th>Setting</th>
            <th>Value</th>
        </tr>
        <tr>
            <td>Debug Level</td>
            <td>Set <code>DEBUG_WEBHOOK_LEVEL</code> in .env (0=off, 1=basic, 2=verbose)</td>
        </tr>
        <tr>
            <td>Basic Auth</td>
            <td>Configure <code>SWML_BASIC_AUTH_USER</code> and <code>SWML_BASIC_AUTH_PASSWORD</code></td>
        </tr>
    </table>

    <h2>Quick Commands</h2>
    <pre><span class="comment"># Start the agent</span>
up

<span class="comment"># Run tests</span>
pytest tests/ -v

<span class="comment"># Check ngrok URLs</span>
urls

<span class="comment"># Test the endpoint</span>
testapp</pre>

    <div class="footer">
        Powered by <a href="https://signalwire.com">SignalWire</a> and the
        <a href="https://github.com/signalwire/signalwire-agents">SignalWire Agents SDK</a>
    </div>

    <script src="https://cdn.signalwire.com/@signalwire/client"></script>
    <script>
        // Store auth credentials
        let authCreds = null;

        // Tab switching
        function switchTab(tabEl, contentId) {
            const endpoint = tabEl.closest('.endpoint');
            endpoint.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            endpoint.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            tabEl.classList.add('active');
            document.getElementById(contentId).classList.add('active');
        }

        // Copy curl command
        function copyCode(btn) {
            const pre = btn.parentElement.querySelector('pre');
            const text = pre.textContent;
            navigator.clipboard.writeText(text).then(() => {
                const orig = btn.textContent;
                btn.textContent = 'Copied!';
                setTimeout(() => btn.textContent = orig, 1500);
            });
        }

        // Try endpoint in browser
        async function tryEndpoint(method, path, body, responseId, requiresAuth) {
            const responseArea = document.getElementById(responseId);
            responseArea.classList.add('visible');
            responseArea.innerHTML = '<div class="response-status">Loading...</div>';

            const startTime = performance.now();
            try {
                const options = {
                    method: method,
                    headers: {}
                };
                if (body) {
                    options.headers['Content-Type'] = 'application/json';
                    options.body = JSON.stringify(body);
                }
                if (requiresAuth && authCreds) {
                    options.headers['Authorization'] = 'Basic ' + btoa(authCreds.user + ':' + authCreds.password);
                }

                const resp = await fetch(path, options);
                const endTime = performance.now();
                const duration = Math.round(endTime - startTime);

                let data;
                const contentType = resp.headers.get('content-type') || '';
                if (contentType.includes('json')) {
                    data = await resp.json();
                    data = JSON.stringify(data, null, 2);
                } else {
                    data = await resp.text();
                }

                const statusClass = resp.ok ? 'success' : 'error';
                responseArea.innerHTML = `
                    <div class="response-header">
                        <span class="response-status ${statusClass}">${resp.status} ${resp.statusText}</span>
                        <span class="response-time">${duration}ms</span>
                    </div>
                    <div class="response-body">${escapeHtml(data)}</div>
                `;
            } catch (err) {
                responseArea.innerHTML = `
                    <div class="response-header">
                        <span class="response-status error">Error</span>
                    </div>
                    <div class="response-body">${escapeHtml(err.message)}</div>
                `;
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // WebRTC calling
        let client = null;
        let roomSession = null;

        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const destinationInput = document.getElementById('destination');
        const callStatus = document.getElementById('callStatus');

        function updateCallStatus(message) {
            callStatus.textContent = message;
        }

        async function connect() {
            try {
                connectBtn.disabled = true;
                updateCallStatus('Getting token...');

                const tokenResp = await fetch('/get_token');
                const tokenData = await tokenResp.json();

                if (tokenData.error) {
                    throw new Error(tokenData.error);
                }

                if (tokenData.address) {
                    destinationInput.value = tokenData.address;
                }

                updateCallStatus('Connecting...');

                client = await window.SignalWire.SignalWire({
                    token: tokenData.token
                });

                const destination = tokenData.address || destinationInput.value;
                roomSession = await client.dial({
                    to: destination,
                    audio: {
                        echoCancellation: document.getElementById('echoCancellation').checked,
                        noiseSuppression: document.getElementById('noiseSuppression').checked,
                        autoGainControl: document.getElementById('autoGainControl').checked
                    },
                    video: false
                });

                roomSession.on('call.joined', () => {
                    updateCallStatus('Connected');
                    disconnectBtn.disabled = false;
                });

                roomSession.on('call.left', () => {
                    updateCallStatus('Call ended');
                    cleanup();
                });

                roomSession.on('destroy', () => {
                    updateCallStatus('Call ended');
                    cleanup();
                });

                // Start the call
                await roomSession.start();

            } catch (err) {
                console.error('Connection error:', err);
                updateCallStatus('Error: ' + err.message);
                cleanup();
            }
        }

        async function disconnect() {
            try {
                if (roomSession) {
                    await roomSession.hangup();
                }
            } catch (err) {
                console.error('Disconnect error:', err);
            }
            cleanup();
        }

        function cleanup() {
            connectBtn.disabled = false;
            disconnectBtn.disabled = true;
            roomSession = null;
            client = null;
        }

        connectBtn.addEventListener('click', connect);
        disconnectBtn.addEventListener('click', disconnect);

        // Update base URLs and fetch credentials on load
        document.addEventListener('DOMContentLoaded', async function() {
            const baseUrl = window.location.origin;
            document.querySelectorAll('.base-url').forEach(function(el) {
                el.textContent = baseUrl;
            });

            // Fetch auth credentials for curl examples
            try {
                const credsResp = await fetch('/get_credentials');
                if (credsResp.ok) {
                    authCreds = await credsResp.json();
                    document.querySelectorAll('.auth-creds').forEach(function(el) {
                        el.textContent = authCreds.user + ':' + authCreds.password;
                    });
                }
            } catch (e) {
                console.log('Could not fetch credentials:', e);
                document.querySelectorAll('.auth-creds').forEach(function(el) {
                    el.textContent = 'user:password';
                });
            }
        });
    </script>
</body>
</html>
HTMLEOF
print_success "web/index.html"

# Initialize venv with spinner
print_step "Creating virtual environment..."

VENV_DIR="/workdir/.venvs/${NAME}"
python3 -m venv "$VENV_DIR"
source "$VENV_DIR/bin/activate"

# Install packages with spinner
printf "Installing packages... "
spinner='|/-\'
i=0
pip install -q flask requests signalwire-agents python-dotenv pytest > /dev/null 2>&1 &
pid=$!
while kill -0 $pid 2>/dev/null; do
    printf "\b%c" "${spinner:i%4:1}"
    i=$((i+1))
    sleep 0.1
done
wait $pid 2>/dev/null
status=$?
if [ $status -eq 0 ]; then
    printf "\bdone\n"
    print_success "Virtual environment created"
else
    printf "\bfailed\n"
    print_error "Package installation failed"
fi

echo ""
echo -e "${GREEN}Project created successfully!${NC}"
echo ""
if [ -n "$NGROK_URL" ]; then
    echo "Your agent will be available at:"
    echo "  SWML: $NGROK_URL/swml"
    echo "  Web:  $NGROK_URL/"
    echo ""
fi
echo "To start your agent:"
echo ""
echo "  cd $PROJECT_DIR"
echo "  up"
echo ""
echo "To run tests:"
echo ""
echo "  pytest tests/ -v"
echo ""
